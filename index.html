<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mind Clock</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Kaisei+Tokumin&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Yusei+Magic&display=swap');


    body {
      width: 700px;
      margin: 0 auto;
      text-align: left;
      padding: 15px;
      box-sizing: border-box;
      background-color: #000;
      color: #0f0;
      font-family: 'Orbitron', sans-serif;
      -webkit-app-region: drag;
    }
    #timerDisplay {
      font-size: 35px;
      margin-bottom: 10px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      user-select: none;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
    }
    #timerDisplay:hover {
      color: #0f0;
      text-shadow: 0 0 10px #0f0;
    }
    #timerDisplay.running {
      color: #0f0;
      text-shadow: 0 0 10px #0f0;
    }
    .timer-controls {
      display: flex;
      gap: 10px;
    }
    .timer-button {
      background: none;
      border: 2px solid #0f0;
      color: #0f0;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 14px;
      padding: 0;
      opacity: 0.7;
    }
    .timer-button:hover {
      opacity: 1;
      background: #0f01;
      box-shadow: 0 0 10px #0f0;
    }
    .timer-button.active {
      opacity: 1;
      background: #0f01;
      box-shadow: 0 0 10px #0f0;
    }
    button {
      font-size: 12px;
      padding: 8px 15px;
      margin: 5px;
      border: none;
      border-radius: 5px;
      background-color: #111;
      color: #0f0;
      box-shadow: 3px 3px 6px #050, -3px -3px 6px #0a0;
      transition: 0.2s;
      cursor: pointer;
      font-family: 'Orbitron', sans-serif;
      -webkit-app-region: no-drag;
    }
    button:hover {
      background-color: #0f0;
      color: #000;
      font-family: 'Orbitron', sans-serif;
    }
    button:active {
      box-shadow: 1px 1px 3px #050, -1px -1px 3px #0a0;
      font-family: 'Orbitron', sans-serif;
    }
    textarea {
      width: 100%;
      font-size: 15px;
      margin: 10px 0;
      resize: none;
      padding: 10px;
      border: 1px solid #0f0;
      border-radius: 5px;
      background-color: #000;
      color: #0f0;
      font-family: 'Kaisei Tokumin', serif;
      box-sizing: border-box;
      overflow: hidden;
      -webkit-app-region: no-drag;
    }
    textarea:focus {
      box-shadow: 0 0 20px #0f04, inset 0 0 20px #0f02;
      background-color: #0c0c0c;
    }
    textarea::placeholder {
      color: #0f0;
      opacity: 0.3;
      text-shadow: 0 0 5px #0f0;
    }
    .input-container {
      position: relative;
      margin: 20px 0;
    }
    .input-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, #0f0, transparent);
    }
    .input-container::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, #0f0, transparent);
    }
    #message {
      font-size: 14px;
      color: #0f0;
      margin-top: 10px;
      display: none;
      font-family: 'Orbitron', sans-serif;
    }
    h1 {
      margin-bottom: 20px;
      font-family: 'Orbitron', sans-serif;
      text-align: center;
    }
    #tweets {
      text-align: left;
      margin-top: 20px;
      font-family: 'Yusei Magic', serif;
    }
    .tweet {
      font-size: 18px;
      margin-bottom: 10px;
      border-bottom: 1px solid #0f0;
      padding: 10px;
      padding-left: 15px;
      font-family: 'Yusei Magic';
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: relative;
      overflow: hidden;
      outline: none;
      cursor: pointer;
      border-radius: 3px;
      -webkit-app-region: no-drag;
      border-left: 5px solid transparent;
      box-sizing: border-box;
    }
    .tweet:focus {
      background: rgba(0, 255, 0, 0.05);
      box-shadow: 0 0 10px #0f03;
      border-left: 5px solid #0f0;
      padding-left: 15px;
    }
    .tweet:hover {
      background: rgba(0, 255, 0, 0.02);
    }
    .tweet .content {
      flex-grow: 1;
      margin-right: 15px;
      white-space: pre-wrap;
    }
    .tweet span.time {
      font-size: 12px;
      color: #0f0;
      opacity: 0.5;
      font-family: 'Orbitron', sans-serif;
      margin-right: 10px;
      min-width: 85px;
      text-align: right;
    }
    .tweet:hover span.time {
      opacity: 1;
    }
    /* 子ツイート関連のスタイル */
    .tweet.child-tweet {
      margin-left: 20px;
      font-size: 16px;
      border-left: 5px solid transparent;
      border-bottom: 1px dashed #0f0;
    }
    .tweet.child-tweet:focus {
      border-left: 5px solid #0f0;
    }
    .tweet .child-indicator {
      position: absolute;
      left: -15px;
      top: 50%;
      transform: translateY(-50%);
      color: #0f0;
      font-size: 14px;
      opacity: 0.7;
    }
    .tweet .has-children-indicator {
      margin-right: 5px;
      color: #0f0;
      font-size: 14px;
      cursor: pointer;
      opacity: 0.7;
    }
    .tweet .has-children-indicator:hover {
      opacity: 1;
    }
    .children-container {
      margin-left: 20px;
      border-left: 1px dashed #0f0;
      padding-left: 10px;
      display: none;
    }
    .children-container.expanded {
      display: block;
    }
    .tweet-actions {
      display: flex;
      gap: 5px;
      margin-right: 5px;
    }
    .tweet-action {
      color: #0f0;
      opacity: 0.5;
      cursor: pointer;
      font-size: 14px;
    }
    .tweet-action:hover {
      opacity: 1;
    }
    .controls-info {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.9);
      border: 1px solid #0f0;
      border-radius: 10px;
      padding: 20px;
      z-index: 1000;
      box-shadow: 0 0 20px #0f0;
      max-width: 80%;
      max-height: 80%;
      overflow-y: auto;
    }
    .controls-info:hover {
      opacity: 1;
    }
    .shortcut-group {
      font-size: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .key {
      background: #0f01;
      padding: 2px 6px;
      border-radius: 3px;
      border: 1px solid #0f02;
      font-family: 'Orbitron', sans-serif;
      text-transform: uppercase;
    }
    .key-separator {
      opacity: 0.5;
    }
    .flush-btn {
      position: absolute;
      right: 15px;
      bottom: 15px;
      background-color: #111;
      color: #f00;
      border: none;
      padding: 4px 12px;
      cursor: pointer;
      font-size: 12px;
      font-family: 'Orbitron', sans-serif;
      text-transform: uppercase;
      box-shadow: 2px 2px 4px #500, -2px -2px 4px #500;
      transition: all 0.2s ease;
      border-radius: 3px;
      letter-spacing: 1px;
      opacity: 0.4;
      -webkit-app-region: no-drag;
    }
    .flush-btn:hover {
      opacity: 1;
      background-color: #200;
      color: #f00;
      box-shadow: 3px 3px 6px #500, -3px -3px 6px #500;
      text-shadow: 0 0 5px #f00;
    }
    .flush-btn:active {
      box-shadow: 1px 1px 2px #500, -1px -1px 2px #500;
    }
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      -webkit-app-region: no-drag;
    }
    .modal-content {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #111;
      padding: 20px;
      border-radius: 5px;
      border: 1px solid #0f0;
      box-shadow: 0 0 20px #0f04;
      z-index: 1001;
      text-align: center;
      font-family: 'Orbitron', sans-serif;
    }
    .modal-message {
      color: #0f0;
      margin-bottom: 20px;
      font-size: 14px;
    }
    .modal-buttons {
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    .modal-btn {
      padding: 5px 15px;
      border: 1px solid #0f0;
      background: #111;
      color: #0f0;
      cursor: pointer;
      transition: all 0.2s;
      font-family: 'Orbitron', sans-serif;
      font-size: 12px;
    }
    .modal-btn:hover {
      background: #0f0;
      color: #000;
    }
    .modal-btn.cancel {
      border-color: #f00;
      color: #f00;
    }
    .modal-btn.cancel:hover {
      background: #f00;
      color: #000;
    }
    @keyframes matrix-rain {
      0% {
        transform: translateY(-100%);
        opacity: 0;
      }
      50% {
        opacity: 0.8;
      }
      100% {
        transform: translateY(100%);
        opacity: 0;
      }
    }
    .tweet.matrix-effect::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(180deg, rgba(0, 255, 0, 0.5) 0%, transparent 100%);
      animation: matrix-rain 1s linear;
      pointer-events: none;
      z-index: 1;
    }
    .tweet.editing .content {
      background: rgba(0, 255, 0, 0.05);
      padding: 5px;
      border-radius: 3px;
      outline: none;
      border-bottom: 2px solid #0f0;
      transition: all 0.2s ease;
    }
    .tweet.editing .content:focus {
      background: rgba(0, 255, 0, 0.08);
      border-bottom: 2px solid #0f0;
      box-shadow: 0 4px 8px rgba(0, 255, 0, 0.1);
    }
    .tweet.new-tweet {
      border: 1px solid #0f03;
      margin-bottom: 20px;
      background: rgba(0, 255, 0, 0.02);
    }
    .tweet.new-tweet.editing {
      background: rgba(0, 255, 0, 0.05);
    }
    .tweet.new-tweet .content {
      color: #0f07;
    }
    .tweet.new-tweet.editing .content {
      color: #0f0;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin: 10px 0;
      -webkit-app-region: no-drag;
    }
    .controls button {
      flex: 0 0 auto;
    }
    .shortcuts h3 {
      color: #0f0;
      text-align: center;
      margin-top: 0;
    }
    .shortcuts ul {
      list-style-type: none;
      padding: 0;
    }
    .shortcuts li {
      margin: 10px 0;
      color: #0f0;
    }
    kbd {
      background-color: #111;
      border: 1px solid #0f0;
      border-radius: 3px;
      box-shadow: 0 1px 1px rgba(0, 255, 0, 0.2);
      color: #0f0;
      display: inline-block;
      font-size: 0.85em;
      font-family: 'Orbitron', sans-serif;
      line-height: 1;
      padding: 2px 4px;
      white-space: nowrap;
    }
    .tweet.focused {
      border-left: 5px solid #ff0 !important;
      background: rgba(255, 255, 0, 0.08) !important;
      box-shadow: 0 0 15px rgba(255, 255, 0, 0.3) !important;
      position: relative;
      z-index: 2;
    }
    .tweet.focused::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border: 1px solid rgba(255, 255, 0, 0.3);
      pointer-events: none;
      z-index: -1;
    }
    .tweet.focused .content {
      color: #ff0 !important;
      text-shadow: 0 0 2px rgba(255, 255, 0, 0.5) !important;
    }
    .tweet.focused:hover {
      background: rgba(255, 255, 0, 0.1) !important;
    }
    .tweet.focused:focus {
      background: rgba(255, 255, 0, 0.12) !important;
      box-shadow: 0 0 20px rgba(255, 255, 0, 0.4) !important;
    }
    .focus-indicator {
      display: inline-block;
      margin-right: 8px;
      color: #ff0;
      font-size: 16px;
      text-shadow: 0 0 5px rgba(255, 255, 0, 0.7);
    }
  </style>
</head>
<body>
  <div class="controls-info" style="display: none; flex-direction: column; gap: 10px;">
    <h3 style="color: #0f0; text-align: center; margin-bottom: 10px;">キーボードショートカット</h3>
    
    <div style="display: flex; flex-direction: column; gap: 8px;">
      <div class="shortcut-group">
        <span class="key">j</span>
        <span>次のツイートへ移動</span>
      </div>
      <div class="shortcut-group">
        <span class="key">k</span>
        <span>前のツイートへ移動</span>
      </div>
      <div class="shortcut-group">
        <span class="key">i</span>
        <span>選択中のツイートを編集</span>
      </div>
      <div class="shortcut-group">
        <span class="key">d</span>
        <span>選択中のツイートを削除</span>
      </div>
      <div class="shortcut-group">
        <span class="key">o</span>
        <span>選択中のツイートに返信（子ツイート追加）</span>
      </div>
      <div class="shortcut-group">
        <span class="key">space</span>
        <span>選択中のツイートの子ツイート表示/非表示</span>
      </div>
      <div class="shortcut-group">
        <span class="key">⌘</span><span class="key-separator">+</span><span class="key">n</span>
        <span>新規ツイート入力</span>
      </div>
      <div class="shortcut-group">
        <span class="key">⌘</span><span class="key-separator">+</span><span class="key">enter</span>
        <span>ツイート投稿/編集完了</span>
      </div>
      <div class="shortcut-group">
        <span class="key">esc</span>
        <span>編集キャンセル</span>
      </div>
      <div class="shortcut-group">
        <span class="key">⌘</span><span class="key-separator">+</span><span class="key">s</span>
        <span>タイマー開始/停止</span>
      </div>
      <div class="shortcut-group">
        <span class="key">⌘</span><span class="key-separator">+</span><span class="key">shift</span><span class="key-separator">+</span><span class="key">s</span>
        <span>タイマーリセット</span>
      </div>
      <div class="shortcut-group">
        <span class="key">⌘</span><span class="key-separator">+</span><span class="key">shift</span><span class="key-separator">+</span><span class="key">e</span>
        <span>ツイートをテキストとしてエクスポート</span>
      </div>
      <div class="shortcut-group">
        <span class="key">⌘</span><span class="key-separator">+</span><span class="key">shift</span><span class="key-separator">+</span><span class="key">j</span>
        <span>ツイートをJSONとしてエクスポート</span>
      </div>
      <div class="shortcut-group">
        <span class="key">⌘</span><span class="key-separator">+</span><span class="key">shift</span><span class="key-separator">+</span><span class="key">i</span>
        <span>JSONからツイートをインポート</span>
      </div>
      <div class="shortcut-group">
        <span class="key">⌘</span><span class="key-separator">+</span><span class="key">shift</span><span class="key-separator">+</span><span class="key">m</span>
        <span>JSONからツイートをマージ</span>
      </div>
      <div class="shortcut-group">
        <span class="key">⌘</span><span class="key-separator">+</span><span class="key">shift</span><span class="key-separator">+</span><span class="key">d</span>
        <span>全ツイート削除</span>
      </div>
      <div class="shortcut-group">
        <span class="key">⌘</span><span class="key-separator">+</span><span class="key">?</span>
        <span>このヘルプを表示/非表示</span>
      </div>
      <div class="shortcut-group">
        <span class="key">f</span>
        <span>選択中のツイートをフォーカス/フォーカス解除</span>
      </div>
    </div>
  </div>
  <h1>Mind Clock</h1>
  <div id="timerDisplay">
    <span class="time">00:00:00</span>
    <div class="timer-controls">
      <button class="timer-button play-pause" onclick="toggleTimer()">▶</button>
      <button class="timer-button reset" onclick="resetTimer()">↺</button>
    </div>
  </div>
  <div id="message"></div>
  <div id="tweets"></div>
  <div class="controls">
    <button id="exportBtn" title="Export tweets (Ctrl+Shift+E)">Export</button>
    <button id="flushBtn" title="Delete all tweets (Ctrl+Shift+D)">Delete All</button>
    <!-- JSONエクスポート/インポート/マージボタンを追加 -->
    <button id="exportJsonBtn" title="Export as JSON">Export JSON</button>
    <button id="importJsonBtn" title="Import from JSON">Import JSON</button>
    <button id="mergeJsonBtn" title="Merge with JSON">Merge JSON</button>
    <input type="file" id="jsonFileInput" accept=".json" style="display: none;">
    <button id="toggleControlsBtn" title="Toggle shortcuts (Ctrl+?)">Shortcuts</button>
    <button id="focusBtn" title="Focus on selected tweet (Ctrl+F)">Focus</button>
  </div>

  <div class="modal-overlay">
    <div class="modal-content">
      <div class="modal-message">全てのツイートを削除しますか？</div>
      <div class="modal-buttons">
        <button class="modal-btn" onclick="confirmFlush()">OK</button>
        <button class="modal-btn cancel" onclick="cancelFlush()">Cancel</button>
      </div>
    </div>
  </div>

  <script>
    const { ipcRenderer } = require('electron');
    let tweetArray = [];

    // 編集モード中かどうかを確認する関数
    function isEditing() {
      return document.querySelector('.tweet.editing') !== null;
    }

    // イベントリスナーの設定
    document.addEventListener('DOMContentLoaded', async () => {
      // ツイートの読み込み
      try {
        tweetArray = await ipcRenderer.invoke('load-tweets');
        refreshTweetDisplay(tweetArray);
        
        // ツイート表示後にフォーカス状態を復元（遅延実行）
        setTimeout(() => {
          console.log('Delayed focus state restoration');
          restoreFocusState();
        }, 200);
      } catch (error) {
        console.error('Failed to load tweets:', error);
        showMessage('ツイートの読み込みに失敗しました');
      }

      // 新規ツイート入力欄の設定
      const newTweetElement = document.querySelector('.tweet.new-tweet');
      if (newTweetElement) {
        newTweetElement.addEventListener('click', () => {
          if (!newTweetElement.classList.contains('editing')) {
            enterNewTweetEditMode(newTweetElement);
          }
        });
      }

      // エクスポートボタンのイベントリスナー
      document.getElementById('exportBtn').addEventListener('click', exportTweets);
      
      // JSONエクスポートボタンのイベントリスナー
      document.getElementById('exportJsonBtn').addEventListener('click', exportTweetsAsJson);
      
      // JSONインポートボタンのイベントリスナー
      document.getElementById('importJsonBtn').addEventListener('click', importTweetsFromJson);
      
      // JSONマージボタンのイベントリスナー
      document.getElementById('mergeJsonBtn').addEventListener('click', mergeTweetsFromJson);
      
      // ショートカット表示ボタンのイベントリスナー
      document.getElementById('toggleControlsBtn').addEventListener('click', () => {
        const controls = document.querySelector('.controls-info');
        controls.style.display = controls.style.display === 'none' || controls.style.display === '' ? 'flex' : 'none';
      });
      
      // フォーカスボタンのイベントリスナー
      document.getElementById('focusBtn').addEventListener('click', () => {
        console.log('Focus button clicked');
        // 現在フォーカスされているツイートがない場合は、最初のツイートにフォーカスを移動
        const currentFocus = document.activeElement;
        if (!currentFocus || !currentFocus.classList.contains('tweet') || currentFocus.classList.contains('child-tweet') || currentFocus.classList.contains('new-tweet')) {
          const firstTweet = document.querySelector('.tweet:not(.child-tweet):not(.new-tweet)');
          if (firstTweet) {
            firstTweet.focus();
            console.log('Focus moved to first tweet');
          }
        }
        
        // フォーカス機能を実行
        toggleFocusOnTweet();
      });
      
      // 全削除ボタンのイベントリスナー
      document.querySelector('.flush-btn').addEventListener('click', flushTweets);
      
      // モーダルのボタンイベントリスナー
      document.getElementById('confirmFlushBtn').addEventListener('click', confirmFlush);
      document.getElementById('cancelFlushBtn').addEventListener('click', cancelFlush);
    });

    // キーボードショートカットの設定
    document.addEventListener('keydown', (e) => {
      // 編集中の場合はショートカットを無効化
      if (isEditing() && e.key !== 'Escape') {
        return;
      }

      // 新規ツイート入力 (⌘/Ctrl + N)
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'n') {
        e.preventDefault();
        const newTweetElement = document.querySelector('.tweet.new-tweet');
        if (newTweetElement && !newTweetElement.classList.contains('editing')) {
          enterNewTweetEditMode(newTweetElement);
        }
        return;
      }

      // 選択されたツイートの編集 (iキー)
      if (!e.ctrlKey && !e.metaKey && !e.shiftKey && e.key.toLowerCase() === 'i') {
        e.preventDefault();
        const focusedTweet = document.activeElement;
        if (focusedTweet && focusedTweet.classList.contains('tweet')) {
          if (focusedTweet.classList.contains('child-tweet')) {
            // 子ツイートの編集
            const parentIndex = parseInt(focusedTweet.getAttribute('data-parent-index'));
            const childIndex = parseInt(focusedTweet.getAttribute('data-child-index'));
            if (!isNaN(parentIndex) && !isNaN(childIndex)) {
              editChildTweet(parentIndex, childIndex);
            }
          } else if (!focusedTweet.classList.contains('new-tweet')) {
            // 親ツイートの編集
            const actualIndex = parseInt(focusedTweet.getAttribute('data-actual-index'));
            if (!isNaN(actualIndex)) {
              editTweet(actualIndex);
            }
          }
        }
        return;
      }

      // ツイート間の移動 (j/kキー)
      if (!e.ctrlKey && !e.metaKey && !e.shiftKey && (e.key === 'j' || e.key === 'k')) {
        e.preventDefault();
        const currentFocus = document.activeElement;
        
        if (!currentFocus || !currentFocus.classList.contains('tweet')) {
          // フォーカスがツイートにない場合は最初のツイートにフォーカス
          const firstTweet = document.querySelector('.tweet:not(.new-tweet)');
          if (firstTweet) {
            firstTweet.focus();
          }
          return;
        }
        
        // 表示されているすべてのツイート（親と展開されている子）を取得
        const parentTweets = Array.from(document.querySelectorAll('.tweet:not(.child-tweet):not(.new-tweet)'));
        const expandedChildren = Array.from(document.querySelectorAll('.children-container.expanded .tweet.child-tweet'));
        const visibleTweets = [...parentTweets, ...expandedChildren].sort((a, b) => {
          // DOMでの位置に基づいてソート
          return a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
        });
        
        // 子ツイートが表示されているかどうかを確認
        const hasExpandedChildren = document.querySelector('.children-container.expanded') !== null;
        
        if (hasExpandedChildren) {
          // 子ツイートが表示されている場合は、表示されているすべてのツイート間を移動
          const visibleIndex = visibleTweets.indexOf(currentFocus);
          
          if (e.key === 'j') {
            // 次のツイートへ（自分の子ツイートへ）
            if (visibleIndex < visibleTweets.length - 1) {
              visibleTweets[visibleIndex + 1]?.focus();
            } else {
              // 最後のツイートの場合は最初に戻る
              visibleTweets[0]?.focus();
            }
          } else {
            // 前のツイートへ
            if (visibleIndex > 0) {
              visibleTweets[visibleIndex - 1]?.focus();
            } else {
              // 最初のツイートの場合は最後に移動
              visibleTweets[visibleTweets.length - 1]?.focus();
            }
          }
        } else {
          // 子ツイートが表示されていない場合は、親ツイート間を移動
          const parentTweetIndex = parentTweets.indexOf(currentFocus);
          
          if (e.key === 'j') {
            // 次の親ツイートへ
            if (parentTweetIndex < parentTweets.length - 1) {
              parentTweets[parentTweetIndex + 1]?.focus();
            } else {
              // 最後の親ツイートの場合は最初に戻る
              parentTweets[0]?.focus();
            }
          } else {
            // 前の親ツイートへ
            if (parentTweetIndex > 0) {
              parentTweets[parentTweetIndex - 1]?.focus();
            } else {
              // 最初の親ツイートの場合は最後に移動
              parentTweets[parentTweets.length - 1]?.focus();
            }
          }
        }
        return;
      }

      // ショートカット一覧の表示/非表示 (⌘/Ctrl + ?)
      if ((e.ctrlKey || e.metaKey) && (e.key === '?' || e.key === '/')) {
        e.preventDefault();
        const controls = document.querySelector('.controls-info');
        controls.style.display = controls.style.display === 'none' || controls.style.display === '' ? 'flex' : 'none';
        return;
      }

      // フォーカス機能のショートカット (f)
      if (!e.ctrlKey && !e.metaKey && !e.altKey && e.key === 'f') {
        e.preventDefault();
        console.log('Focus shortcut triggered');
        
        // 現在フォーカスされているツイートがない場合は、最初のツイートにフォーカスを移動
        const currentFocus = document.activeElement;
        if (!currentFocus || !currentFocus.classList.contains('tweet') || currentFocus.classList.contains('child-tweet') || currentFocus.classList.contains('new-tweet')) {
          const firstTweet = document.querySelector('.tweet:not(.child-tweet):not(.new-tweet)');
          if (firstTweet) {
            firstTweet.focus();
            console.log('Focus moved to first tweet by shortcut');
          }
        }
        
        toggleFocusOnTweet();
        return;
      }

      // タイマーの開始/停止 (⌘/Ctrl + S)
      if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase() === 's') {
        e.preventDefault(); // デフォルトの保存動作を防ぐ
        toggleTimer();
        return;
      }

      // タイマーのリセット (⌘/Ctrl + Shift + S)
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === 's') {
        e.preventDefault();
        resetTimer();
        return;
      }

      // 新規ツイート入力 (⌘/Ctrl + N)
      if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase() === 'n') {
        e.preventDefault();
        const newTweet = document.querySelector('.tweet.new-tweet');
        if (newTweet) {
          newTweet.focus();
          enterNewTweetEditMode(newTweet);
        }
        return;
      }

      // iキーでツイートを編集
      if (!e.ctrlKey && !e.metaKey && !e.shiftKey && e.key.toLowerCase() === 'i') {
        e.preventDefault();
        const focusedTweet = document.activeElement;
        if (focusedTweet && focusedTweet.classList.contains('tweet')) {
          if (focusedTweet.classList.contains('new-tweet')) {
            enterNewTweetEditMode(focusedTweet);
          } else if (focusedTweet.classList.contains('child-tweet')) {
            // 子ツイートの編集
            const parentIndex = parseInt(focusedTweet.getAttribute('data-parent-index'));
            const childIndex = parseInt(focusedTweet.getAttribute('data-child-index'));
            if (!isNaN(parentIndex) && !isNaN(childIndex)) {
              editChildTweet(parentIndex, childIndex);
            }
          } else {
            // 親ツイートの編集
            const actualIndex = parseInt(focusedTweet.getAttribute('data-actual-index'));
            if (!isNaN(actualIndex)) {
              editTweet(actualIndex);
            }
          }
        }
        return;
      }

      // j,kキーでの移動
      if (!e.ctrlKey && !e.metaKey && !e.shiftKey && (e.key === 'j' || e.key === 'k')) {
        e.preventDefault();
        const allTweets = Array.from(document.querySelectorAll('.tweet'));
        const currentFocus = document.activeElement;
        let currentIndex = allTweets.indexOf(currentFocus);

        // 現在のフォーカスがツイート上にない場合は、最初/最後のツイートにフォーカス
        if (currentIndex === -1) {
          if (e.key === 'j') {
            allTweets[0]?.focus();
          } else {
            allTweets[allTweets.length - 1]?.focus();
          }
          return;
        }

        // 現在フォーカスされているのが子ツイートかどうか
        const isChildTweet = currentFocus.classList.contains('child-tweet');
        
        // 親ツイートのみを取得
        const parentTweets = Array.from(document.querySelectorAll('.tweet:not(.child-tweet)'));
        
        // 表示されている子ツイートを含むすべてのツイートを取得
        const visibleTweets = Array.from(document.querySelectorAll('.tweet:not(.child-tweet), .children-container.expanded .tweet.child-tweet'));
        
        if (isChildTweet) {
          // 子ツイートの場合
          const parentIndex = parseInt(currentFocus.getAttribute('data-parent-index'));
          const parentTweet = document.querySelector(`.tweet[data-actual-index="${parentIndex}"]`);
          
          // 親ツイートの子ツイートコンテナが展開されているかチェック
          const childrenContainer = document.querySelector(`.children-container[data-parent-index="${parentIndex}"]`);
          const isExpanded = childrenContainer && childrenContainer.classList.contains('expanded');
          
          if (isExpanded) {
            // 子ツイートが表示されている場合は、表示されているすべてのツイート間を移動
            const visibleIndex = visibleTweets.indexOf(currentFocus);
            
            if (e.key === 'j') {
              // 次のツイートへ
              if (visibleIndex < visibleTweets.length - 1) {
                visibleTweets[visibleIndex + 1]?.focus();
              } else {
                // 最後のツイートの場合は最初に戻る
                visibleTweets[0]?.focus();
              }
            } else {
              // 前のツイートへ
              if (visibleIndex > 0) {
                visibleTweets[visibleIndex - 1]?.focus();
              } else {
                // 最初のツイートの場合は最後に移動
                visibleTweets[visibleTweets.length - 1]?.focus();
              }
            }
          } else {
            // 子ツイートが表示されていない場合は、親ツイート間を移動
            const parentTweetIndex = parentTweets.indexOf(parentTweet);
            
            if (e.key === 'j') {
              // 次の親ツイートへ
              if (parentTweetIndex < parentTweets.length - 1) {
                parentTweets[parentTweetIndex + 1]?.focus();
              } else {
                // 最後の親ツイートの場合は最初に戻る
                parentTweets[0]?.focus();
              }
            } else {
              // 前の親ツイートへ
              if (parentTweetIndex > 0) {
                parentTweets[parentTweetIndex - 1]?.focus();
              } else {
                // 最初の親ツイートの場合は最後に移動
                parentTweets[parentTweets.length - 1]?.focus();
              }
            }
          }
        } else {
          // 親ツイートの場合
          // この親ツイートの子ツイートコンテナが展開されているかチェック
          const actualIndex = parseInt(currentFocus.getAttribute('data-actual-index'));
          const childrenContainer = document.querySelector(`.children-container[data-parent-index="${actualIndex}"]`);
          const isExpanded = childrenContainer && childrenContainer.classList.contains('expanded');
          
          if (isExpanded && childrenContainer.querySelectorAll('.tweet.child-tweet').length > 0) {
            // 子ツイートが表示されている場合は、表示されているすべてのツイート間を移動
            const visibleIndex = visibleTweets.indexOf(currentFocus);
            
            if (e.key === 'j') {
              // 次のツイートへ（自分の子ツイートへ）
              if (visibleIndex < visibleTweets.length - 1) {
                visibleTweets[visibleIndex + 1]?.focus();
              } else {
                // 最後のツイートの場合は最初に戻る
                visibleTweets[0]?.focus();
              }
            } else {
              // 前のツイートへ
              if (visibleIndex > 0) {
                visibleTweets[visibleIndex - 1]?.focus();
              } else {
                // 最初のツイートの場合は最後に移動
                visibleTweets[visibleTweets.length - 1]?.focus();
              }
            }
          } else {
            // 子ツイートが表示されていない場合は、親ツイート間を移動
            const parentTweetIndex = parentTweets.indexOf(currentFocus);
            
            if (e.key === 'j') {
              // 次の親ツイートへ
              if (parentTweetIndex < parentTweets.length - 1) {
                parentTweets[parentTweetIndex + 1]?.focus();
              } else {
                // 最後の親ツイートの場合は最初に戻る
                parentTweets[0]?.focus();
              }
            } else {
              // 前の親ツイートへ
              if (parentTweetIndex > 0) {
                parentTweets[parentTweetIndex - 1]?.focus();
              } else {
                // 最初の親ツイートの場合は最後に移動
                parentTweets[parentTweets.length - 1]?.focus();
              }
            }
          }
        }
        return;
      }

      // 選択されたツイートの削除 (dキー)
      if (!e.ctrlKey && !e.metaKey && !e.shiftKey && e.key.toLowerCase() === 'd') {
        e.preventDefault();
        const focusedTweet = document.activeElement;
        if (focusedTweet && focusedTweet.classList.contains('tweet')) {
          if (focusedTweet.classList.contains('child-tweet')) {
            // 子ツイートの削除
            const parentIndex = parseInt(focusedTweet.getAttribute('data-parent-index'));
            const childIndex = parseInt(focusedTweet.getAttribute('data-child-index'));
            if (!isNaN(parentIndex) && !isNaN(childIndex)) {
              deleteChildTweet(parentIndex, childIndex);
            }
          } else if (!focusedTweet.classList.contains('new-tweet')) {
            // 親ツイートの削除
            const actualIndex = parseInt(focusedTweet.getAttribute('data-actual-index'));
            if (!isNaN(actualIndex)) {
              deleteTweet(actualIndex);
            }
          }
        }
        return;
      }

      // rキーで選択されたツイートに返信（子ツイート追加）
      if (!e.ctrlKey && !e.metaKey && !e.shiftKey && e.key.toLowerCase() === 'o') {
        e.preventDefault();
        const focusedTweet = document.activeElement;
        if (focusedTweet && focusedTweet.classList.contains('tweet') && !focusedTweet.classList.contains('new-tweet') && !focusedTweet.classList.contains('child-tweet')) {
          const actualIndex = parseInt(focusedTweet.getAttribute('data-actual-index'));
          if (!isNaN(actualIndex)) {
            addChildTweet(actualIndex);
          }
        }
        return;
      }

      // トグルボタン機能（スペースキー）
      if (!e.ctrlKey && !e.metaKey && !e.shiftKey && e.key === ' ') {
        e.preventDefault();
        const focusedTweet = document.activeElement;
        if (focusedTweet && focusedTweet.classList.contains('tweet') && !focusedTweet.classList.contains('child-tweet') && !focusedTweet.classList.contains('new-tweet')) {
          const actualIndex = parseInt(focusedTweet.getAttribute('data-actual-index'));
          if (!isNaN(actualIndex)) {
            toggleChildrenVisibility(actualIndex);
          }
        }
        return;
      }
    });

    const tweetEffects = [
      {
        name: 'matrix-effect',
        duration: 1000
      }
    ];

    async function postTweet(content) {
      if (content) {
        const newTweet = {
          content: content.replace(/\n/g, '<br>'),
          timestamp: new Date().toISOString(),
          children: [] // 子ツイート配列を初期化
        };

        try {
          // まず永続化を試みる
          tweetArray.push(newTweet);
          await ipcRenderer.invoke('save-tweets', tweetArray);

          // 永続化成功後にUIを更新
          const actualIndex = tweetArray.length - 1; // 新しいツイートの実際のインデックス
          const tweet = createTweetElement(newTweet, 0, actualIndex);
          
          // 新規ツイート入力欄の後に挿入
          const newTweetElement = document.querySelector('.tweet.new-tweet');
          if (newTweetElement && newTweetElement.nextSibling) {
            document.getElementById('tweets').insertBefore(tweet, newTweetElement.nextSibling);
          } else {
            // フォールバック: 新規ツイート入力欄が見つからない場合は先頭に追加
            document.getElementById('tweets').prepend(tweet);
          }

          // 既存のツイートのインデックスを更新
          const existingTweets = document.querySelectorAll('.tweet:not(.new-tweet):not(.child-tweet)');
          existingTweets.forEach(existingTweet => {
            // 新しく追加したツイート以外のインデックスを更新
            if (existingTweet !== tweet) {
              const oldIndex = parseInt(existingTweet.getAttribute('data-index'));
              existingTweet.setAttribute('data-index', oldIndex + 1);
            }
          });

          // マトリックスエフェクトを適用
          tweet.classList.add('matrix-effect');
          setTimeout(() => {
            tweet.classList.remove('matrix-effect');
          }, 1000);

          return true;
        } catch (error) {
          console.error('Failed to save tweet:', error);
          // エラーが発生した場合、配列から削除して元に戻す
          tweetArray.pop();
          throw error;
        }
      }
      return false;
    }

    function formatTime(timestamp) {
      const date = new Date(timestamp);
      const now = new Date();
      const diffMinutes = Math.floor((now - date) / (1000 * 60));

      // 1分未満は「NOW」と表示
      if (diffMinutes < 1) return 'NOW';
      
      // 日付と時刻を「mm/dd hh:mm」形式でフォーマット
      const month = (date.getMonth() + 1).toString().padStart(2, '0');
      const day = date.getDate().toString().padStart(2, '0');
      const hours = date.getHours().toString().padStart(2, '0');
      const minutes = date.getMinutes().toString().padStart(2, '0');
      
      return `${month}/${day} ${hours}:${minutes}`;
    }

    let timer;
    let startTime;
    let accumulatedTime = 0;
    let running = false;

    const coolMessages = [
      "Data has been launched into the cosmos 🚀",
      "Your words are now beyond infinity!",
      "The Enter key can't believe this!",
      "This moment has changed the world!",
      "Magic of coding unleashed!",
      "Information has transcended dimensions!",
      "This copy is rare indeed!",
      "Invincible paste ready!",
      "Text is transcending dimensions!",
      "Data races through the network!",
      "This copy will go down in history!",
      "Your message shines brightly!",
      "Copy complete, grand departure!",
      "Astonishing coding power!",
      "First step into uncharted territory!",
      "Thought has been materialized!",
      "Data races through time and space!",
      "Information moving at light speed!",
      "Everyone praises this copy!",
      "Legendary copy complete!",
      "Your input is now reaching the future!",
      "Inspiration is unstoppable!",
      "Infinite possibilities take flight!",
      "The best copy, surprising the world!",
      "Imagination has been digitized!",
      "The future awaits you!",
      "This text is art at heart!",
      "Information moving like lightning!",
      "Message has soared into the universe!",
      "Input complete, infinite possibilities ahead!"
    ];

    function autoResize(elem) {
      const minHeight = 80; // 最小の高さも80pxに

      // スクロールの高さを正確に計測するための一時的な高さリセット
      elem.style.height = 'auto';

      // 実際のコンテンツの高さを取得（最小値は保持）
      const newHeight = Math.max(elem.scrollHeight, minHeight);

      // 現在の高さと新しい高さが異なる場合のみ更新
      if (elem.clientHeight !== newHeight) {
        elem.style.height = newHeight + 'px';
      }
    }

    function updateTimerDisplay() {
      if (!running && accumulatedTime === 0) {
        document.querySelector('#timerDisplay .time').textContent = "Click to Start";
        return;
      }
      const elapsed = Math.floor((Date.now() - startTime + accumulatedTime) / 1000);
      const hours = Math.floor(elapsed / 3600);
      const minutes = Math.floor((elapsed % 3600) / 60);
      const seconds = elapsed % 60;
      document.querySelector('#timerDisplay .time').textContent =
          `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    async function copyToClipboard() {
      try {
        await navigator.clipboard.writeText(taskInput);
        const message = coolMessages[Math.floor(Math.random() * coolMessages.length)];
        showMessage(message);
      } catch (err) {
        console.error('Failed to copy to clipboard:', err);
      }
    }

    function showMessage(text) {
      const messageDiv = document.getElementById('message');
      messageDiv.textContent = text;
      messageDiv.style.display = 'block';
      setTimeout(() => {
        messageDiv.style.display = 'none';
      }, 3000);
    }

    function toggleTimer() {
      if (running) {
        stopTimer();
      } else {
        startTimer();
      }
    }

    function startTimer() {
      if (!running) {
        running = true;
        startTime = Date.now();
        timer = setInterval(updateTimerDisplay, 1000);
        updateTimerDisplay();
        document.getElementById('timerDisplay').classList.add('running');
        document.querySelector('.timer-button.play-pause').textContent = '⏸';
      }
    }

    function stopTimer() {
      if (running) {
        running = false;
        clearInterval(timer);
        accumulatedTime += Date.now() - startTime;
        document.getElementById('timerDisplay').classList.remove('running');
        document.querySelector('.timer-button.play-pause').textContent = '▶';
      }
    }

    function resetTimer() {
      running = false;
      clearInterval(timer);
      accumulatedTime = 0
      document.querySelector('#timerDisplay .time').textContent = "00:00:00";
      document.getElementById('timerDisplay').classList.remove('running');
      document.querySelector('.timer-button.play-pause').textContent = '▶';
    }

    // タイマーディスプレイのクリックイベントを追加
    document.querySelector('#timerDisplay .time').addEventListener('click', function(e) {
      toggleTimer();
    });

    async function exportTweets() {
      try {
        let exportText = '';
        
        // ツイートを新しい順に処理
        for (let i = tweetArray.length - 1; i >= 0; i--) {
          const tweet = tweetArray[i];
          
          // 親ツイートの内容と時間を追加
          const tweetDate = new Date(tweet.timestamp);
          const tweetDateStr = tweetDate.toLocaleString('ja-JP');
          exportText += `${tweetDateStr}  ${tweet.content.replace(/<br>/g, '\n')}\n\n`;
          
          // 子ツイートがあれば追加
          if (tweet.children && tweet.children.length > 0) {
            tweet.children.forEach(childTweet => {
              // 子ツイートの時間とコンテンツを追加
              const childDate = new Date(childTweet.timestamp);
              const childDateStr = childDate.toLocaleString('ja-JP');
              exportText += `\t${childDateStr}  ${childTweet.content.replace(/<br>/g, '\n').replace(/\n/g, '\n\t')}\n\n`;
            });
          }
        }
        
        // クリップボードにコピー - 改善版
        try {
          // 非同期APIを使用
          await navigator.clipboard.writeText(exportText);
          showMessage('エクスポートに成功しました。');
        } catch (clipboardErr) {
          console.error('クリップボードAPIエラー:', clipboardErr);
          
          // フォールバック: 一時的なテキストエリアを使用
          const textArea = document.createElement('textarea');
          textArea.value = exportText;
          textArea.style.position = 'fixed';
          textArea.style.left = '-999999px';
          textArea.style.top = '-999999px';
          document.body.appendChild(textArea);
          textArea.focus();
          textArea.select();
          
          try {
            const successful = document.execCommand('copy');
            if (successful) {
              showMessage('エクスポートに成功しました。');
            } else {
              throw new Error('execCommand copy failed');
            }
          } catch (execErr) {
            console.error('execCommand エラー:', execErr);
            alert('クリップボードへのコピーに失敗しました。');
          } finally {
            document.body.removeChild(textArea);
          }
        }
      } catch (error) {
        console.error('エクスポートエラー:', error);
        alert('エクスポートに失敗しました。');
      }
    }

    // JSONエクスポート機能
    async function exportTweetsAsJson() {
      try {
        const tweets = await ipcRenderer.invoke('export-tweets-json');
        if (tweets.length === 0) {
          alert('エクスポートするツイートがありません。');
          return;
        }

        // JSONデータを作成
        const jsonData = JSON.stringify(tweets, null, 2);
        
        // Blobを作成
        const blob = new Blob([jsonData], { type: 'application/json' });
        
        // ダウンロードリンクを作成
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        
        // 現在の日時をファイル名に含める
        const now = new Date();
        const dateStr = now.toISOString().replace(/[:.]/g, '-').replace('T', '_').split('Z')[0];
        a.download = `mind_clock_export_${dateStr}.json`;
        
        
        // リンクをクリックしてダウンロード
        document.body.appendChild(a);
        a.click();
        
        // クリーンアップ
        setTimeout(() => {
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }, 100);
        
        showMessage('JSONファイルがエクスポートされました！');
      } catch (error) {
        console.error('JSONエクスポートエラー:', error);
        alert(`エクスポート中にエラーが発生しました: ${error.message}`);
      }
    }

    // JSONインポート機能
    async function importTweetsFromJson() {
      try {
        // ファイル選択ダイアログを表示
        const fileInput = document.getElementById('jsonFileInput');
        fileInput.onchange = async (event) => {
          const file = event.target.files[0];
          if (!file) return;
          
          const reader = new FileReader();
          reader.onload = async (e) => {
            try {
              const jsonData = JSON.parse(e.target.result);
              
              // 確認ダイアログを表示
              if (confirm('現在のデータを上書きしますか？キャンセルを選択すると、マージモードになります。')) {
                // インポート（上書き）
                const importedTweets = await ipcRenderer.invoke('import-tweets-json', jsonData);
                refreshTweetDisplay(importedTweets);
                showMessage('JSONデータがインポートされました！');
              } else {
                // マージ
                const mergedTweets = await ipcRenderer.invoke('merge-tweets-json', jsonData);
                refreshTweetDisplay(mergedTweets);
                showMessage('JSONデータがマージされました！');
              }
            } catch (error) {
              console.error('JSONパースエラー:', error);
              alert(`JSONファイルの解析中にエラーが発生しました: ${error.message}`);
            }
            
            // ファイル入力をリセット
            fileInput.value = '';
          };
          reader.readAsText(file);
        };
        
        fileInput.click();
      } catch (error) {
        console.error('JSONインポートエラー:', error);
        alert(`インポート中にエラーが発生しました: ${error.message}`);
      }
    }

    // JSONマージ機能
    async function mergeTweetsFromJson() {
      try {
        // ファイル選択ダイアログを表示
        const fileInput = document.getElementById('jsonFileInput');
        fileInput.onchange = async (event) => {
          const file = event.target.files[0];
          if (!file) return;
          
          const reader = new FileReader();
          reader.onload = async (e) => {
            try {
              const jsonData = JSON.parse(e.target.result);
              
              // マージ処理
              const mergedTweets = await ipcRenderer.invoke('merge-tweets-json', jsonData);
              refreshTweetDisplay(mergedTweets);
              showMessage('JSONデータがマージされました！');
            } catch (error) {
              console.error('JSONパースエラー:', error);
              alert(`JSONファイルの解析中にエラーが発生しました: ${error.message}`);
            }
            
            // ファイル入力をリセット
            fileInput.value = '';
          };
          reader.readAsText(file);
        };
        
        fileInput.click();
      } catch (error) {
        console.error('JSONマージエラー:', error);
        alert(`マージ中にエラーが発生しました: ${error.message}`);
      }
    }

    // ツイート表示を更新する共通関数
    function refreshTweetDisplay(tweets) {
      tweetArray = tweets;
      const tweetsContainer = document.getElementById('tweets');
      tweetsContainer.innerHTML = '';
      
      // 新規ツイート入力欄を追加（最初に）
      const newTweetElement = document.createElement('div');
      newTweetElement.className = 'tweet new-tweet';
      newTweetElement.setAttribute('tabindex', '0');
      newTweetElement.innerHTML = `
        <span class="content">Initialize thought sequence...</span>
      `;
      tweetsContainer.appendChild(newTweetElement);
      
      // 新規ツイート入力欄のクリックイベントを設定
      newTweetElement.addEventListener('click', () => {
        if (!newTweetElement.classList.contains('editing')) {
          enterNewTweetEditMode(newTweetElement);
        }
      });
      
      // ツイートを表示（新しい順）
      for (let idx = 0; idx < tweetArray.length; idx++) {
        const tweetIndex = tweetArray.length - 1 - idx; // 表示順序は逆だが、実際のインデックスを使用
        const tweet = tweetArray[tweetIndex];
        
        // 親ツイートを作成
        const tweetElement = createTweetElement(tweet, idx, tweetIndex);
        tweetsContainer.appendChild(tweetElement);
        
        // 子ツイートがある場合は子ツイートコンテナを作成
        if (tweet.children && tweet.children.length > 0) {
          const childrenContainer = document.createElement('div');
          childrenContainer.className = 'children-container expanded'; // 基本的に表示状態にする
          childrenContainer.setAttribute('data-parent-index', tweetIndex);
          
          // 子ツイートを表示
          tweet.children.forEach((childTweet, childIdx) => {
            const childElement = createChildTweetElement(childTweet, childIdx, tweetIndex);
            childrenContainer.appendChild(childElement);
          });
          
          // 子ツイートコンテナを親ツイートの後に追加
          tweetsContainer.insertBefore(childrenContainer, tweetElement.nextSibling);
          
          // 親ツイートに子ツイートがあることを示すインジケータを追加
          const hasChildrenIndicator = document.createElement('span');
          hasChildrenIndicator.className = 'has-children-indicator';
          hasChildrenIndicator.textContent = '▼'; // 基本的に開いた状態
          hasChildrenIndicator.setAttribute('title', '子ツイートを表示/非表示');
          hasChildrenIndicator.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleChildrenVisibility(tweetIndex);
          });
          
          // インジケータを親ツイートのコンテンツの前に追加
          const contentSpan = tweetElement.querySelector('.content');
          tweetElement.insertBefore(hasChildrenIndicator, contentSpan);
        }
      }
      
      console.log('Refreshed tweet display, now restoring focus state');
      
      // ツイート表示後にフォーカス状態を復元
      setTimeout(() => {
        restoreFocusState();
      }, 100);
    }

    // 親ツイート要素を作成する関数
    function createTweetElement(tweet, displayIndex, actualIndex) {
      const tweetElement = document.createElement('div');
      tweetElement.className = 'tweet';
      tweetElement.setAttribute('data-text', tweet.content);
      tweetElement.setAttribute('data-index', displayIndex); // 表示順のインデックスを設定（0から始まる）
      tweetElement.setAttribute('data-actual-index', actualIndex); // 実際のデータ配列のインデックスも保存
      tweetElement.setAttribute('tabindex', '0');
      
      // コンテンツと時間を別々に作成して追加
      const contentSpan = document.createElement('span');
      contentSpan.className = 'content';
      contentSpan.innerHTML = tweet.content; // innerHTMLを使用して<br>タグを正しく解釈
      
      const timeSpan = document.createElement('span');
      timeSpan.className = 'time';
      timeSpan.textContent = formatTime(tweet.timestamp);
      
      // アクションボタンを追加
      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'tweet-actions';
      
      // 返信ボタン
      const replyButton = document.createElement('span');
      replyButton.className = 'tweet-action reply-action';
      replyButton.textContent = '↩';
      replyButton.setAttribute('title', '返信する');
      replyButton.addEventListener('click', (e) => {
        e.stopPropagation();
        addChildTweet(actualIndex);
      });
      
      actionsDiv.appendChild(replyButton);
      
      tweetElement.appendChild(contentSpan);
      tweetElement.appendChild(actionsDiv);
      tweetElement.appendChild(timeSpan);
      
      return tweetElement;
    }

    // 子ツイート要素を作成する関数
    function createChildTweetElement(childTweet, childIndex, parentIndex) {
      const childElement = document.createElement('div');
      childElement.className = 'tweet child-tweet';
      childElement.setAttribute('data-text', childTweet.content);
      childElement.setAttribute('data-child-index', childIndex);
      childElement.setAttribute('data-parent-index', parentIndex);
      childElement.setAttribute('tabindex', '0');
      
      // 子ツイートのインジケータ
      const childIndicator = document.createElement('span');
      childIndicator.className = 'child-indicator';
      childIndicator.textContent = '↪';
      
      // コンテンツと時間を別々に作成して追加
      const contentSpan = document.createElement('span');
      contentSpan.className = 'content';
      contentSpan.innerHTML = childTweet.content;
      
      const timeSpan = document.createElement('span');
      timeSpan.className = 'time';
      timeSpan.textContent = formatTime(childTweet.timestamp);
      
      childElement.appendChild(childIndicator);
      childElement.appendChild(contentSpan);
      childElement.appendChild(timeSpan);
      
      return childElement;
    }

    // 子ツイートの表示/非表示を切り替える関数
    function toggleChildrenVisibility(parentIndex) {
      const childrenContainer = document.querySelector(`.children-container[data-parent-index="${parentIndex}"]`);
      if (childrenContainer) {
        childrenContainer.classList.toggle('expanded');
        
        // インジケータの向きを変更
        const parentTweet = document.querySelector(`.tweet[data-actual-index="${parentIndex}"]`);
        const indicator = parentTweet.querySelector('.has-children-indicator');
        if (indicator) {
          indicator.textContent = childrenContainer.classList.contains('expanded') ? '▼' : '▶';
        }
      }
    }

    // 子ツイートを追加する関数
    async function addChildTweet(parentIndex) {
      const parentTweet = document.querySelector(`.tweet[data-actual-index="${parentIndex}"]`);
      if (!parentTweet) return;
      
      // 子ツイート入力用の要素を作成
      const childInputElement = document.createElement('div');
      childInputElement.className = 'tweet child-tweet editing';
      childInputElement.setAttribute('data-parent-index', parentIndex);
      
      // 子ツイートのインジケータ
      const childIndicator = document.createElement('span');
      childIndicator.className = 'child-indicator';
      childIndicator.textContent = '↪';
      
      // 編集可能なコンテンツ要素
      const contentSpan = document.createElement('span');
      contentSpan.className = 'content';
      contentSpan.contentEditable = true;
      contentSpan.textContent = '';
      
      childInputElement.appendChild(childIndicator);
      childInputElement.appendChild(contentSpan);
      
      // 子ツイートコンテナを取得または作成
      let childrenContainer = document.querySelector(`.children-container[data-parent-index="${parentIndex}"]`);
      if (!childrenContainer) {
        childrenContainer = document.createElement('div');
        childrenContainer.className = 'children-container';
        childrenContainer.setAttribute('data-parent-index', parentIndex);
        
        // 親ツイートの後に子ツイートコンテナを挿入
        parentTweet.parentNode.insertBefore(childrenContainer, parentTweet.nextSibling);
        
        // 親ツイートに子ツイートがあることを示すインジケータを追加（まだなければ）
        if (!parentTweet.querySelector('.has-children-indicator')) {
          const hasChildrenIndicator = document.createElement('span');
          hasChildrenIndicator.className = 'has-children-indicator';
          hasChildrenIndicator.textContent = '▶';
          hasChildrenIndicator.setAttribute('title', '子ツイートを表示/非表示');
          hasChildrenIndicator.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleChildrenVisibility(parentIndex);
          });
          
          // インジケータを親ツイートのコンテンツの前に追加
          const contentSpan = parentTweet.querySelector('.content');
          parentTweet.insertBefore(hasChildrenIndicator, contentSpan);
        }
      }
      
      // 子ツイートコンテナを表示
      childrenContainer.classList.add('expanded');
      
      // インジケータの向きを変更
      const indicator = parentTweet.querySelector('.has-children-indicator');
      if (indicator) {
        indicator.textContent = '▼';
      }
      
      // 子ツイート入力要素を子ツイートコンテナの先頭に追加
      childrenContainer.insertBefore(childInputElement, childrenContainer.firstChild);
      
      // フォーカスを設定
      contentSpan.focus();
      
      // IME入力状態を追跡
      let isComposing = false;
      
      // IME入力開始イベントのリスナー
      const handleCompositionStart = () => {
        isComposing = true;
      };
      
      // IME入力終了イベントのリスナー
      const handleCompositionEnd = () => {
        isComposing = false;
      };
      
      // 編集完了のイベントリスナー
      const handleEditKeypress = async (e) => {
        // cmd + enterで保存
        if (e.key === 'Enter' && (e.metaKey || e.ctrlKey) && !isComposing) {
          e.preventDefault();
          e.stopPropagation();
          const newContent = contentSpan.textContent.trim();
          
          if (newContent) {
            try {
              // 子ツイートを追加
              const childTweet = {
                content: newContent.replace(/\n/g, '<br>'),
                timestamp: new Date().toISOString()
              };
              
              // バックエンドに子ツイートを追加
              tweetArray = await ipcRenderer.invoke('add-child-tweet', parentIndex, childTweet);
              
              // 編集モードを終了
              finishEditing();
              
              // ツイート一覧を再描画
              refreshTweetDisplay(tweetArray);
            } catch (error) {
              console.error('Failed to add child tweet:', error);
              finishEditing();
            }
          } else {
            finishEditing();
          }
        } else if (e.key === 'Escape') {
          // 編集をキャンセル
          e.preventDefault();
          e.stopPropagation();
          finishEditing();
        }
      };
      
      // 編集モード終了時の共通処理
      const finishEditing = () => {
        document.removeEventListener('keydown', handleEditKeypress);
        contentSpan.removeEventListener('compositionstart', handleCompositionStart);
        contentSpan.removeEventListener('compositionend', handleCompositionEnd);
        
        // 入力要素を削除
        if (childInputElement.parentNode) {
          childInputElement.parentNode.removeChild(childInputElement);
        }
        
        // 子ツイートがない場合は子ツイートコンテナとインジケータを削除
        const existingChildTweets = childrenContainer.querySelectorAll('.tweet.child-tweet:not(.editing)');
        if (existingChildTweets.length === 0) {
          // 子ツイートコンテナを削除
          if (childrenContainer.parentNode) {
            childrenContainer.parentNode.removeChild(childrenContainer);
          }
          
          // インジケータを削除
          if (indicator) {
            indicator.parentNode.removeChild(indicator);
          }
        }
      };
      
      // イベントリスナーを追加
      document.addEventListener('keydown', handleEditKeypress);
      contentSpan.addEventListener('compositionstart', handleCompositionStart);
      contentSpan.addEventListener('compositionend', handleCompositionEnd);
    }

    // 子ツイートを編集する関数
    async function editChildTweet(parentIndex, childIndex) {
      const childTweet = document.querySelector(`.tweet.child-tweet[data-parent-index="${parentIndex}"][data-child-index="${childIndex}"]`);
      if (!childTweet) return;
      
      const contentSpan = childTweet.querySelector('.content');
      const originalContent = contentSpan.innerHTML.replace(/<br>/g, '\n');
      let isComposing = false;
      
      // 編集モードに入る
      childTweet.classList.add('editing');
      contentSpan.contentEditable = true;
      contentSpan.textContent = originalContent;
      contentSpan.focus();
      
      // IME入力開始イベントのリスナー
      const handleCompositionStart = () => {
        isComposing = true;
      };
      
      // IME入力終了イベントのリスナー
      const handleCompositionEnd = () => {
        isComposing = false;
      };
      
      // 編集完了のイベントリスナー
      const handleEditKeypress = async (e) => {
        // cmd + enterで保存
        if (e.key === 'Enter' && (e.metaKey || e.ctrlKey) && !isComposing) {
          e.preventDefault();
          e.stopPropagation();
          const newContent = contentSpan.textContent.trim();
          
          if (newContent !== originalContent) {
            try {
              // 子ツイートの内容を更新
              tweetArray = await ipcRenderer.invoke('edit-child-tweet', parentIndex, childIndex, newContent.replace(/\n/g, '<br>'));
              
              // 表示を更新
              contentSpan.innerHTML = newContent.replace(/\n/g, '<br>');
              contentSpan.contentEditable = false;
              childTweet.classList.remove('editing');
              childTweet.focus();
            } catch (error) {
              console.error('Failed to edit child tweet:', error);
              // エラー時は元の内容に戻す
              contentSpan.innerHTML = originalContent;
              finishEditing();
            }
          } else {
            finishEditing();
          }
        } else if (e.key === 'Escape') {
          // 編集をキャンセル
          e.preventDefault();
          e.stopPropagation();
          contentSpan.innerHTML = originalContent;
          finishEditing();
        }
      };
      
      // 編集モード終了時の共通処理
      const finishEditing = () => {
        contentSpan.contentEditable = false;
        childTweet.classList.remove('editing');
        childTweet.focus();
        document.removeEventListener('keydown', handleEditKeypress);
        contentSpan.removeEventListener('compositionstart', handleCompositionStart);
        contentSpan.removeEventListener('compositionend', handleCompositionEnd);
      };
      
      // イベントリスナーを追加
      document.addEventListener('keydown', handleEditKeypress);
      contentSpan.addEventListener('compositionstart', handleCompositionStart);
      contentSpan.addEventListener('compositionend', handleCompositionEnd);
    }

    // 子ツイートを削除する関数
    async function deleteChildTweet(parentIndex, childIndex) {
      const childTweet = document.querySelector(`.tweet.child-tweet[data-parent-index="${parentIndex}"][data-child-index="${childIndex}"]`);
      if (!childTweet) return;
      
      if (!childTweet.classList.contains('confirm')) {
        // 最初の確認時
        childTweet.classList.add('confirm');
        childTweet.style.background = 'rgba(255, 0, 0, 0.1)';
        
        // キーボードイベントリスナーを追加
        const handleDeleteKeypress = async (e) => {
          if (e.key === 'Enter') {
            // Enterキーで削除実行
            document.removeEventListener('keydown', handleDeleteKeypress);
            document.removeEventListener('focusin', handleOtherFocus);
            
            try {
              // 子ツイートを削除
              tweetArray = await ipcRenderer.invoke('delete-child-tweet', parentIndex, childIndex);
              
              // ツイート一覧を再描画
              refreshTweetDisplay(tweetArray);
            } catch (error) {
              console.error('Failed to delete child tweet:', error);
              childTweet.classList.remove('confirm');
              childTweet.style.background = '';
            }
          } else if (e.key === 'Escape') {
            // Escキーでキャンセル
            document.removeEventListener('keydown', handleDeleteKeypress);
            document.removeEventListener('focusin', handleOtherFocus);
            childTweet.classList.remove('confirm');
            childTweet.style.background = '';
          }
        };
        
        document.addEventListener('keydown', handleDeleteKeypress);
        
        // 他のツイートがフォーカスされた時のイベントリスナー
        const handleOtherFocus = (e) => {
          if (e.target.classList.contains('tweet') && e.target !== childTweet) {
            document.removeEventListener('keydown', handleDeleteKeypress);
            document.removeEventListener('focusin', handleOtherFocus);
            childTweet.classList.remove('confirm');
            childTweet.style.background = '';
          }
        };
        
        document.addEventListener('focusin', handleOtherFocus);
      }
    }

    async function deleteTweet(index) {
      const focusedTweet = document.activeElement;
      if (!focusedTweet || !focusedTweet.classList.contains('tweet')) return;
      
      // data-actual-index属性から実際のデータ配列内のインデックスを取得
      const actualIndex = parseInt(focusedTweet.getAttribute('data-actual-index'));
      if (isNaN(actualIndex)) {
        console.error('Invalid tweet index');
        return;
      }
      
      if (!focusedTweet.classList.contains('confirm')) {
        // 最初の確認時
        focusedTweet.classList.add('confirm');
        focusedTweet.style.background = 'rgba(255, 0, 0, 0.1)';
        
        // キーボードイベントリスナーを追加
        const handleDeleteKeypress = async (e) => {
          if (e.key === 'Enter') {
            // Enterキーで削除実行
            document.removeEventListener('keydown', handleDeleteKeypress);
            document.removeEventListener('focusin', handleOtherFocus);
            await executeDelete(actualIndex);
          } else if (e.key === 'Escape') {
            // Escキーでキャンセル
            document.removeEventListener('keydown', handleDeleteKeypress);
            document.removeEventListener('focusin', handleOtherFocus);
            focusedTweet.classList.remove('confirm');
            focusedTweet.style.background = '';
          }
        };
        
        document.addEventListener('keydown', handleDeleteKeypress);
        
        // 他のツイートがフォーカスされた時のイベントリスナー
        const handleOtherFocus = (e) => {
          if (e.target.classList.contains('tweet') && e.target !== focusedTweet) {
            document.removeEventListener('keydown', handleDeleteKeypress);
            document.removeEventListener('focusin', handleOtherFocus);
            focusedTweet.classList.remove('confirm');
            focusedTweet.style.background = '';
          }
        };
        
        document.addEventListener('focusin', handleOtherFocus);
        
        return;
      }
    }

    async function executeDelete(index) {
      try {
        // フォーカスされているツイート要素を取得
        const focusedTweet = document.activeElement;
        if (!focusedTweet || !focusedTweet.classList.contains('tweet')) return;
        
        // data-actual-index属性から実際のデータ配列内のインデックスを取得
        const actualIndex = parseInt(focusedTweet.getAttribute('data-actual-index'));
        
        if (isNaN(actualIndex)) {
          console.error('Invalid tweet index');
          return;
        }
        
        tweetArray = await ipcRenderer.invoke('delete-tweet', actualIndex);
        // ツイート一覧を再描画
        refreshTweetDisplay(tweetArray);
      } catch (error) {
        console.error('Failed to delete tweet:', error);
      }
    }

    async function flushTweets() {
      showModal();
    }

    function showModal() {
      document.querySelector('.modal-overlay').style.display = 'block';
      // モーダル表示時のキーボードイベントリスナーを追加
      document.addEventListener('keydown', handleModalKeypress);
    }

    function hideModal() {
      document.querySelector('.modal-overlay').style.display = 'none';
      // モーダル非表示時のキーボードイベントリスナーを削除
      document.removeEventListener('keydown', handleModalKeypress);
    }

    function handleModalKeypress(e) {
      if (e.key === 'Enter') {
        confirmFlush();
      } else if (e.key === 'Escape') {
        cancelFlush();
      }
    }

    async function confirmFlush() {
      hideModal();
      try {
        tweetArray = await ipcRenderer.invoke('flush-tweets');
        document.getElementById('tweets').innerHTML = '';
      } catch (error) {
        console.error('Failed to flush tweets:', error);
      }
    }

    function cancelFlush() {
      hideModal();
    }

    async function editTweet(index) {
      const focusedTweet = document.activeElement;
      if (!focusedTweet || !focusedTweet.classList.contains('tweet')) return;
      
      // data-actual-index属性から実際のデータ配列内のインデックスを取得
      const actualIndex = parseInt(focusedTweet.getAttribute('data-actual-index'));
      if (isNaN(actualIndex)) {
        console.error('Invalid tweet index');
        return;
      }
      
      const contentSpan = focusedTweet.querySelector('.content');
      const originalContent = contentSpan.innerHTML.replace(/<br>/g, '\n');
      let isComposing = false;
      
      // 編集モードに入る
      focusedTweet.classList.add('editing');
      contentSpan.contentEditable = true;
      contentSpan.textContent = originalContent;
      contentSpan.focus();

      // IME入力開始イベントのリスナー
      const handleCompositionStart = () => {
        isComposing = true;
      };

      // IME入力終了イベントのリスナー
      const handleCompositionEnd = () => {
        isComposing = false;
      };
      
      // 編集完了のイベントリスナー
      const handleEditKeypress = async (e) => {
        // cmd + enterで保存
        if (e.key === 'Enter' && (e.metaKey || e.ctrlKey) && !isComposing) {
          e.preventDefault();
          e.stopPropagation();
          const newContent = contentSpan.textContent.trim();

          if (newContent !== originalContent) {
            // ツイートの内容を更新
            tweetArray[actualIndex].content = newContent.replace(/\n/g, '<br>');

            // 保存
            try {
              await ipcRenderer.invoke('save-tweets', tweetArray);
              // 表示を更新
              focusedTweet.setAttribute('data-text', newContent);
              contentSpan.innerHTML = newContent.replace(/\n/g, '<br>');
              contentSpan.contentEditable = false;
              focusedTweet.classList.remove('editing');
              focusedTweet.focus();
            } catch (error) {
              console.error('Failed to save edited tweet:', error);
              // エラー時は元の内容に戻す
              contentSpan.innerHTML = originalContent;
              finishEditing();
            }
          } else {
            finishEditing();
          }
        } else if (e.key === 'Escape') {
          // 編集をキャンセル
          e.preventDefault();
          e.stopPropagation();
          contentSpan.innerHTML = originalContent;
          finishEditing();
        }
      };

      // 編集モード終了時の共通処理
      const finishEditing = () => {
        contentSpan.contentEditable = false;
        focusedTweet.classList.remove('editing');
        focusedTweet.focus();
        document.removeEventListener('keydown', handleEditKeypress);
        contentSpan.removeEventListener('compositionstart', handleCompositionStart);
        contentSpan.removeEventListener('compositionend', handleCompositionEnd);
      };
      
      // イベントリスナーを追加
      document.addEventListener('keydown', handleEditKeypress);
      contentSpan.addEventListener('compositionstart', handleCompositionStart);
      contentSpan.addEventListener('compositionend', handleCompositionEnd);
    }

    // 新規ツイート入力モードに入る処理
    function enterNewTweetEditMode(tweetElement) {
      const contentSpan = tweetElement.querySelector('.content');
      let isComposing = false;

      // プレースホルダーテキストをクリア
      if (contentSpan.textContent === 'Initialize thought sequence...') {
        contentSpan.textContent = '';
      }

      // 編集モードに入る
      tweetElement.classList.add('editing');
      contentSpan.contentEditable = true;
      contentSpan.focus();

      // IME入力開始イベントのリスナー
      const handleCompositionStart = () => {
        isComposing = true;
      };

      // IME入力終了イベントのリスナー
      const handleCompositionEnd = () => {
        isComposing = false;
      };

      // 編集完了のイベントリスナー
      const handleEditKeypress = async (e) => {
        // cmd + enterで投稿
        if (e.key === 'Enter' && (e.metaKey || e.ctrlKey) && !isComposing) {
          e.preventDefault();
          e.stopPropagation();
          const newContent = contentSpan.textContent.trim();

          if (newContent) {
            try {
              // ツイートを投稿
              await postTweet(newContent);
              // 入力欄をリセット
              contentSpan.textContent = '';
              contentSpan.focus();
            } catch (error) {
              console.error('Failed to post tweet:', error);
              showMessage('ツイートの投稿に失敗しました');
            }
          } else {
            finishNewTweetEditing();
          }
        } else if (e.key === 'Escape') {
          // 編集をキャンセル
          e.preventDefault();
          e.stopPropagation();
          contentSpan.textContent = 'Initialize thought sequence...';
          finishNewTweetEditing();
        } else if (e.key === 'Enter' && !e.metaKey && !e.ctrlKey) {
          // 通常のEnterキーは改行として処理
          e.stopPropagation();
        }
      };

      // 新規ツイート入力モード終了時の共通処理
      const finishNewTweetEditing = () => {
        contentSpan.contentEditable = false;
        tweetElement.classList.remove('editing');
        tweetElement.focus();
        document.removeEventListener('keydown', handleEditKeypress);
        contentSpan.removeEventListener('compositionstart', handleCompositionStart);
        contentSpan.removeEventListener('compositionend', handleCompositionEnd);
      };

      // イベントリスナーを追加
      document.addEventListener('keydown', handleEditKeypress);
      contentSpan.addEventListener('compositionstart', handleCompositionStart);
      contentSpan.addEventListener('compositionend', handleCompositionEnd);
    }

    // フォーカス機能の実装
    let focusedTweetIndex = null;

    // ツイートにフォーカスを設定する関数
    function toggleFocusOnTweet() {
      const focusedTweet = document.activeElement;
      console.log('Active element:', focusedTweet);
      
      if (!focusedTweet || !focusedTweet.classList.contains('tweet') || focusedTweet.classList.contains('child-tweet')) {
        console.log('No valid tweet to focus');
        return;
      }
      
      // data-actual-index属性から実際のデータ配列内のインデックスを取得
      const actualIndex = parseInt(focusedTweet.getAttribute('data-actual-index'));
      if (isNaN(actualIndex)) {
        console.error('Invalid tweet index');
        return;
      }
      
      console.log('Toggle focus on tweet with index:', actualIndex);
      console.log('Current focused tweet index:', focusedTweetIndex);
      
      // 現在のフォーカス状態を確認
      if (focusedTweetIndex === actualIndex) {
        // 同じツイートがフォーカスされている場合はフォーカスを解除
        console.log('Removing focus');
        focusedTweetIndex = null;
        
        // すべてのツイートからフォーカスクラスを削除
        const focusedElements = document.querySelectorAll('.tweet.focused');
        console.log('Found focused elements to remove:', focusedElements.length);
        
        focusedElements.forEach(tweet => {
          tweet.classList.remove('focused');
          console.log('Removed focused class from tweet');
          
          const focusIndicator = tweet.querySelector('.focus-indicator');
          if (focusIndicator) {
            focusIndicator.remove();
            console.log('Removed focus indicator');
          }
        });
        
        // フォーカス状態を保存
        try {
          localStorage.removeItem('focusedTweetIndex');
          console.log('Focus state removed from localStorage');
        } catch (e) {
          console.error('Error removing focus state from localStorage:', e);
        }
      } else {
        // 新しいツイートをフォーカス
        console.log('Setting new focus');
        
        // 以前のフォーカスを解除
        const previousFocused = document.querySelectorAll('.tweet.focused');
        console.log('Found previously focused elements:', previousFocused.length);
        
        previousFocused.forEach(tweet => {
          tweet.classList.remove('focused');
          console.log('Removed focused class from previous tweet');
          
          const focusIndicator = tweet.querySelector('.focus-indicator');
          if (focusIndicator) {
            focusIndicator.remove();
            console.log('Removed previous focus indicator');
          }
        });
        
        // 新しいフォーカスを設定
        focusedTweetIndex = actualIndex;
        
        // フォーカスクラスを追加
        focusedTweet.classList.add('focused');
        console.log('Added focused class to new tweet');
        
        // フォーカスインジケータを追加
        const contentElement = focusedTweet.querySelector('.content');
        if (contentElement) {
          const focusIndicator = document.createElement('span');
          focusIndicator.className = 'focus-indicator';
          focusIndicator.innerHTML = '★';
          contentElement.insertBefore(focusIndicator, contentElement.firstChild);
          console.log('Added focus indicator to new tweet');
        } else {
          console.log('Content element not found in tweet');
        }
        
        // フォーカス状態を保存
        try {
          localStorage.setItem('focusedTweetIndex', actualIndex.toString());
          console.log('Focus state saved as:', actualIndex.toString());
        } catch (e) {
          console.error('Error saving focus state to localStorage:', e);
        }
        
        // デバッグ情報
        console.log('After toggle, focused tweet index:', focusedTweetIndex);
        console.log('Focused elements:', document.querySelectorAll('.tweet.focused').length);
        console.log('Focus indicators:', document.querySelectorAll('.focus-indicator').length);
      }
    }

    // 保存されたフォーカス状態を復元する関数
    function restoreFocusState() {
      let savedFocusIndex = null;
      
      try {
        savedFocusIndex = localStorage.getItem('focusedTweetIndex');
        console.log('Restoring focus state, saved index:', savedFocusIndex);
      } catch (e) {
        console.error('Error reading focus state from localStorage:', e);
        return;
      }
      
      if (savedFocusIndex && savedFocusIndex !== 'null') {
        const parsedIndex = parseInt(savedFocusIndex, 10);
        if (isNaN(parsedIndex)) {
          console.log('Invalid saved focus index:', savedFocusIndex);
          return;
        }
        
        focusedTweetIndex = parsedIndex;
        console.log('Parsed focus index:', focusedTweetIndex);
        
        // 少し遅延させてDOMが完全に読み込まれた後に実行
        setTimeout(() => {
          const tweetToFocus = document.querySelector(`.tweet[data-actual-index="${focusedTweetIndex}"]:not(.child-tweet)`);
          console.log('Tweet to focus:', tweetToFocus);
          
          if (tweetToFocus) {
            // フォーカスクラスを追加
            tweetToFocus.classList.add('focused');
            console.log('Added focused class to tweet');
            
            // フォーカスインジケータを追加
            const contentElement = tweetToFocus.querySelector('.content');
            if (contentElement) {
              // 既存のインジケータがあれば削除
              const existingIndicator = contentElement.querySelector('.focus-indicator');
              if (existingIndicator) {
                existingIndicator.remove();
                console.log('Removed existing focus indicator');
              }
              
              const focusIndicator = document.createElement('span');
              focusIndicator.className = 'focus-indicator';
              focusIndicator.innerHTML = '★';
              contentElement.insertBefore(focusIndicator, contentElement.firstChild);
              console.log('Added focus indicator to tweet content');
            }
            
            console.log('Focus applied to element');
          } else {
            console.log('Tweet to focus not found');
            // ツイートが見つからない場合はフォーカス状態をリセット
            focusedTweetIndex = null;
            try {
              localStorage.removeItem('focusedTweetIndex');
              console.log('Focus state removed from localStorage (tweet not found)');
            } catch (e) {
              console.error('Error removing focus state from localStorage:', e);
            }
          }
        }, 200); // 遅延を200ミリ秒に短縮
      } else {
        console.log('No focus to restore');
        focusedTweetIndex = null;
      }
    }

    // イベントリスナーの設定
    document.addEventListener('DOMContentLoaded', () => {
      // ... existing code ...
      
      // フォーカスボタンのイベントリスナー
      document.getElementById('focusBtn').addEventListener('click', () => {
        console.log('Focus button clicked');
        // 現在フォーカスされているツイートがない場合は、最初のツイートにフォーカスを移動
        const currentFocus = document.activeElement;
        if (!currentFocus || !currentFocus.classList.contains('tweet') || currentFocus.classList.contains('child-tweet') || currentFocus.classList.contains('new-tweet')) {
          const firstTweet = document.querySelector('.tweet:not(.child-tweet):not(.new-tweet)');
          if (firstTweet) {
            firstTweet.focus();
          }
        }
        
        // フォーカス機能を実行
        toggleFocusOnTweet();
      });
      
      // キーボードショートカットの追加
      document.addEventListener('keydown', (e) => {
        // ... existing code ...
        
        // フォーカス機能のショートカット (f)
        if (e.key === 'f' && !e.ctrlKey && !e.metaKey && !e.altKey && !isEditing()) {
          e.preventDefault();
          toggleFocusOnTweet();
        }
      });
      
      // 初期表示時にフォーカス状態を復元
      restoreFocusState();
    });
  </script>
</body>
</html>
