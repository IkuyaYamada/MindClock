<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mind Clock</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Kaisei+Tokumin&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Yusei+Magic&display=swap');


    body {
      width: 700px;
      margin: 0 auto;
      text-align: left;
      padding: 15px;
      box-sizing: border-box;
      background-color: #000;
      color: #0f0;
      font-family: 'Orbitron', sans-serif;
      -webkit-app-region: drag;
    }
    #timerDisplay {
      font-size: 35px;
      margin-bottom: 10px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      user-select: none;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
    }
    #timerDisplay:hover {
      color: #0f0;
      text-shadow: 0 0 10px #0f0;
    }
    #timerDisplay.running {
      color: #0f0;
      text-shadow: 0 0 10px #0f0;
    }
    .timer-controls {
      display: flex;
      gap: 10px;
    }
    .timer-button {
      background: none;
      border: 2px solid #0f0;
      color: #0f0;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 14px;
      padding: 0;
      opacity: 0.7;
    }
    .timer-button:hover {
      opacity: 1;
      background: #0f01;
      box-shadow: 0 0 10px #0f0;
    }
    .timer-button.active {
      opacity: 1;
      background: #0f01;
      box-shadow: 0 0 10px #0f0;
    }
    button {
      font-size: 12px;
      padding: 8px 15px;
      margin: 5px;
      border: none;
      border-radius: 5px;
      background-color: #111;
      color: #0f0;
      box-shadow: 3px 3px 6px #050, -3px -3px 6px #0a0;
      transition: 0.2s;
      cursor: pointer;
      font-family: 'Orbitron', sans-serif;
      -webkit-app-region: no-drag;
    }
    button:hover {
      background-color: #0f0;
      color: #000;
      font-family: 'Orbitron', sans-serif;
    }
    button:active {
      box-shadow: 1px 1px 3px #050, -1px -1px 3px #0a0;
      font-family: 'Orbitron', sans-serif;
    }
    textarea {
      width: 100%;
      font-size: 15px;
      margin: 10px 0;
      resize: none;
      padding: 10px;
      border: 1px solid #0f0;
      border-radius: 5px;
      background-color: #000;
      color: #0f0;
      font-family: 'Kaisei Tokumin', serif;
      box-sizing: border-box;
      overflow: hidden;
      -webkit-app-region: no-drag;
    }
    textarea:focus {
      box-shadow: 0 0 20px #0f04, inset 0 0 20px #0f02;
      background-color: #0c0c0c;
    }
    textarea::placeholder {
      color: #0f0;
      opacity: 0.3;
      text-shadow: 0 0 5px #0f0;
    }
    .input-container {
      position: relative;
      margin: 20px 0;
    }
    .input-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, #0f0, transparent);
    }
    .input-container::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, #0f0, transparent);
    }
    #message {
      font-size: 14px;
      color: #0f0;
      margin-top: 10px;
      display: none;
      font-family: 'Orbitron', sans-serif;
    }
    h1 {
      margin-bottom: 20px;
      font-family: 'Orbitron', sans-serif;
      text-align: center;
    }
    #tweets {
      text-align: left;
      margin-top: 20px;
      font-family: 'Yusei Magic', serif;
    }
    .tweet {
      font-size: 18px;
      margin-bottom: 10px;
      border-bottom: 1px solid #0f0;
      padding: 10px;
      padding-left: 15px;
      font-family: 'Yusei Magic';
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: relative;
      overflow: hidden;
      outline: none;
      cursor: pointer;
      border-radius: 3px;
      -webkit-app-region: no-drag;
      border-left: 5px solid transparent;
      box-sizing: border-box;
    }
    .tweet:focus {
      background: rgba(0, 255, 0, 0.05);
      box-shadow: 0 0 10px #0f03;
      border-left: 5px solid #0f0;
      padding-left: 15px;
    }
    .tweet:hover {
      background: rgba(0, 255, 0, 0.02);
    }
    .tweet .content {
      flex-grow: 1;
      margin-right: 15px;
      white-space: pre-wrap;
    }
    .tweet span.time {
      font-size: 12px;
      color: #0f0;
      opacity: 0.5;
      font-family: 'Orbitron', sans-serif;
      margin-right: 10px;
      min-width: 85px;
      text-align: right;
    }
    .tweet:hover span.time {
      opacity: 1;
    }
    /* 子ツイート関連のスタイル */
    .tweet.child-tweet {
      margin-left: 20px;
      font-size: 16px;
      border-left: 5px solid transparent;
      border-bottom: 1px dashed #0f0;
    }
    .tweet.child-tweet:focus {
      border-left: 5px solid #0f0;
    }
    .tweet .child-indicator {
      position: absolute;
      left: -15px;
      top: 50%;
      transform: translateY(-50%);
      color: #0f0;
      font-size: 14px;
      opacity: 0.7;
    }
    .tweet .has-children-indicator {
      margin-right: 5px;
      color: #0f0;
      font-size: 14px;
      cursor: pointer;
      opacity: 0.7;
    }
    .tweet .has-children-indicator:hover {
      opacity: 1;
    }
    .children-container {
      margin-left: 20px;
      border-left: 1px dashed #0f0;
      padding-left: 10px;
      display: none;
    }
    .children-container.expanded {
      display: block;
    }
    .tweet-actions {
      display: flex;
      gap: 5px;
      margin-right: 5px;
    }
    .tweet-action {
      color: #0f0;
      opacity: 0.5;
      cursor: pointer;
      font-size: 14px;
    }
    .tweet-action:hover {
      opacity: 1;
    }
    .controls-info {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.9);
      border: 1px solid #0f0;
      border-radius: 10px;
      padding: 20px;
      z-index: 1000;
      box-shadow: 0 0 20px #0f0;
      max-width: 80%;
      max-height: 80%;
      overflow-y: auto;
    }
    .controls-info:hover {
      opacity: 1;
    }
    .shortcut-group {
      font-size: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .key {
      background: #0f01;
      padding: 2px 6px;
      border-radius: 3px;
      border: 1px solid #0f02;
      font-family: 'Orbitron', sans-serif;
      text-transform: uppercase;
    }
    .key-separator {
      opacity: 0.5;
    }
    .flush-btn {
      position: absolute;
      right: 15px;
      bottom: 15px;
      background-color: #111;
      color: #f00;
      border: none;
      padding: 4px 12px;
      cursor: pointer;
      font-size: 12px;
      font-family: 'Orbitron', sans-serif;
      text-transform: uppercase;
      box-shadow: 2px 2px 4px #500, -2px -2px 4px #500;
      transition: all 0.2s ease;
      border-radius: 3px;
      letter-spacing: 1px;
      opacity: 0.4;
      -webkit-app-region: no-drag;
    }
    .flush-btn:hover {
      opacity: 1;
      background-color: #200;
      color: #f00;
      box-shadow: 3px 3px 6px #500, -3px -3px 6px #500;
      text-shadow: 0 0 5px #f00;
    }
    .flush-btn:active {
      box-shadow: 1px 1px 2px #500, -1px -1px 2px #500;
    }
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      -webkit-app-region: no-drag;
    }
    .modal-content {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #111;
      padding: 20px;
      border-radius: 5px;
      border: 1px solid #0f0;
      box-shadow: 0 0 20px #0f04;
      z-index: 1001;
      text-align: center;
      font-family: 'Orbitron', sans-serif;
    }
    .modal-message {
      color: #0f0;
      margin-bottom: 20px;
      font-size: 14px;
    }
    .modal-buttons {
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    .modal-btn {
      padding: 5px 15px;
      border: 1px solid #0f0;
      background: #111;
      color: #0f0;
      cursor: pointer;
      transition: all 0.2s;
      font-family: 'Orbitron', sans-serif;
      font-size: 12px;
    }
    .modal-btn:hover {
      background: #0f0;
      color: #000;
    }
    .modal-btn.cancel {
      border-color: #f00;
      color: #f00;
    }
    .modal-btn.cancel:hover {
      background: #f00;
      color: #000;
    }
    @keyframes matrix-rain {
      0% {
        transform: translateY(-100%);
        opacity: 0;
      }
      50% {
        opacity: 0.8;
      }
      100% {
        transform: translateY(100%);
        opacity: 0;
      }
    }
    @keyframes matrix-effect {
      0% {
        background-color: rgba(0, 255, 0, 0);
        text-shadow: 0 0 0px rgba(0, 255, 0, 0);
      }
      25% {
        background-color: rgba(0, 255, 0, 0.2);
        text-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
      }
      50% {
        background-color: rgba(255, 204, 0, 0.3);
        text-shadow: 0 0 15px rgba(255, 204, 0, 1);
      }
      75% {
        background-color: rgba(255, 204, 0, 0.2);
        text-shadow: 0 0 10px rgba(255, 204, 0, 0.8);
      }
      100% {
        background-color: rgba(255, 204, 0, 0.1);
        text-shadow: 0 0 5px rgba(255, 204, 0, 0.5);
      }
    }
    .tweet.matrix-effect::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(180deg, rgba(0, 255, 0, 0.5) 0%, transparent 100%);
      animation: matrix-rain 1s linear;
      pointer-events: none;
      z-index: 1;
    }
    .tweet.mind-hook-matrix-effect {
      animation: matrix-effect 1s ease-in-out;
    }
    .tweet.mind-hook-matrix-effect .content {
      position: relative;
      z-index: 2;
    }
    .tweet.mind-hook-matrix-effect::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(180deg, rgba(255, 204, 0, 0.5) 0%, transparent 100%);
      animation: matrix-rain 1s linear;
      pointer-events: none;
      z-index: 1;
    }
    .tweet.editing .content {
      background: rgba(0, 255, 0, 0.05);
      padding: 5px;
      border-radius: 3px;
      outline: none;
      border-bottom: 2px solid #0f0;
      transition: all 0.2s ease;
    }
    .tweet.editing .content:focus {
      background: rgba(0, 255, 0, 0.08);
      border-bottom: 2px solid #0f0;
      box-shadow: 0 4px 8px rgba(0, 255, 0, 0.1);
    }
    .tweet.new-tweet {
      border: 1px solid #0f03;
      margin-bottom: 20px;
      background: rgba(0, 255, 0, 0.02);
    }
    .tweet.new-tweet.editing {
      background: rgba(0, 255, 0, 0.05);
    }
    .tweet.new-tweet .content {
      color: #0f07;
    }
    .tweet.new-tweet.editing .content {
      color: #0f0;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin: 10px 0;
      -webkit-app-region: no-drag;
    }
    .controls button {
      flex: 0 0 auto;
    }
    .shortcuts h3 {
      color: #0f0;
      text-align: center;
      margin-top: 0;
    }
    .shortcuts ul {
      list-style-type: none;
      padding: 0;
    }
    .shortcuts li {
      margin: 10px 0;
      color: #0f0;
    }
    kbd {
      background-color: #111;
      border: 1px solid #0f0;
      border-radius: 3px;
      box-shadow: 0 1px 1px rgba(0, 255, 0, 0.2);
      color: #0f0;
      display: inline-block;
      font-size: 0.85em;
      font-family: 'Orbitron', sans-serif;
      line-height: 1;
      padding: 2px 4px;
      white-space: nowrap;
    }
    .tweet.focused {
      border-left: 5px solid #ff0 !important;
      background: rgba(255, 255, 0, 0.08) !important;
      box-shadow: 0 0 15px rgba(255, 255, 0, 0.3) !important;
      position: relative;
      z-index: 2;
    }
    .tweet.focused::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border: 1px solid rgba(255, 255, 0, 0.3);
      pointer-events: none;
      z-index: -1;
    }
    .tweet.focused .content {
      color: #ff0 !important;
      text-shadow: 0 0 2px rgba(255, 255, 0, 0.5) !important;
    }
    .tweet.focused:hover {
      background: rgba(255, 255, 0, 0.1) !important;
    }
    .tweet.focused:focus {
      background: rgba(255, 255, 0, 0.12) !important;
      box-shadow: 0 0 20px rgba(255, 255, 0, 0.4) !important;
    }
    .focus-indicator {
      display: inline-block;
      margin-right: 8px;
      color: #ff0;
      font-size: 16px;
      text-shadow: 0 0 5px rgba(255, 255, 0, 0.7);
    }
    
    /* マインドフック関連のスタイル */
    .tweet.mind-hooked {
      border-left: 5px solid #ffcc00 !important;
      background-color: rgba(255, 204, 0, 0.15) !important;
      box-shadow: 0 0 15px rgba(255, 204, 0, 0.5) !important;
      position: relative;
    }
    
    .tweet.mind-hooked::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border: 1px solid rgba(255, 204, 0, 0.5);
      pointer-events: none;
    }
    
    .tweet.mind-hooked .content {
      color: #ffcc00 !important;
      text-shadow: 0 0 2px rgba(255, 204, 0, 0.3);
    }
    
    .tweet.mind-hooked:hover,
    .tweet.mind-hooked:focus {
      background-color: rgba(255, 204, 0, 0.2) !important;
      box-shadow: 0 0 20px rgba(255, 204, 0, 0.6) !important;
    }
    
    /* マインドフックインジケータのスタイル */
    .mind-hook-indicator {
      display: inline-block;
      margin-right: 8px;
      color: #ffcc00;
      font-size: 1.2em;
      text-shadow: 0 0 5px rgba(255, 204, 0, 0.7);
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% { opacity: 0.7; }
      50% { opacity: 1; }
      100% { opacity: 0.7; }
    }
    
    /* マインドフックカウントとボタンのスタイル */
    .mind-hook-count {
      display: inline-block;
      margin-left: 5px;
      font-size: 12px;
      color: #ffcc00;
    }
    
    .mind-hook-btn {
      position: relative;
    }
    
    .mind-hook-btn .mind-hook-count {
      position: absolute;
      top: -5px;
      right: -5px;
      background: #ffcc00;
      color: #000;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: bold;
    }
    
    /* マトリックスエフェクト */
    .matrix-effect {
      animation: matrixEffect 1s;
    }
    
    @keyframes matrixEffect {
      0% {
        text-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00, 0 0 15px #00ff00;
        box-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00, 0 0 15px #00ff00;
      }
      100% {
        text-shadow: none;
        box-shadow: none;
      }
    }
  </style>
</head>
<body>
  <div class="controls-info" style="display: none;">
    <div class="shortcuts">
      <h3>キーボードショートカット</h3>
      <ul>
        <li><kbd>Ctrl</kbd> + <kbd>Enter</kbd> - ツイートを投稿</li>
        <li><kbd>e</kbd> - 選択したツイートを編集</li>
        <li><kbd>d</kbd> - 選択したツイートを削除</li>
        <li><kbd>o</kbd> - 選択したツイートに返信（子ツイート追加）</li>
        <li><kbd>Space</kbd> - 子ツイートの表示/非表示を切り替え</li>
        <li><kbd>Tab</kbd> / <kbd>Shift</kbd> + <kbd>Tab</kbd> - ツイート間を移動</li>
        <li><kbd>↑</kbd> / <kbd>↓</kbd> - ツイート間を移動</li>
        <li><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>E</kbd> - エクスポート</li>
        <li><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>J</kbd> - JSONエクスポート</li>
        <li><kbd>f</kbd> - 選択したツイートをマインドフック</li>
        <li><kbd>Alt</kbd> + <kbd>↑</kbd> / <kbd>Alt</kbd> + <kbd>↓</kbd> - マインドフックされたツイート間を移動</li>
      </ul>
    </div>
  </div>
  <h1>Mind Clock</h1>
  <div id="timerDisplay">
    <span class="time">00:00:00</span>
    <div class="timer-controls">
      <button class="timer-button play-pause" onclick="toggleTimer()">▶</button>
      <button class="timer-button reset" onclick="resetTimer()">↺</button>
    </div>
  </div>
  <div id="message"></div>
  <div id="tweets"></div>
  <div class="controls">
    <button id="exportBtn" title="Export tweets (Ctrl+Shift+E)">Export</button>
    <button id="flushBtn" title="Delete all tweets (Ctrl+Shift+D)">Delete All</button>
    <!-- JSONエクスポート/インポート/マージボタンを追加 -->
    <button id="exportJsonBtn" title="Export as JSON">Export JSON</button>
    <button id="importJsonBtn" title="Import from JSON">Import JSON</button>
    <button id="mergeJsonBtn" title="Merge with JSON">Merge JSON</button>
    <input type="file" id="jsonFileInput" accept=".json" style="display: none;">
    <button id="toggleControlsBtn" title="Toggle shortcuts (Ctrl+?)">Shortcuts</button>
    <button id="mindHookBtn" class="mind-hook-btn" title="Mind Hook selected tweet (F key)">Mind Hook<span class="mind-hook-count" style="display: none;">0</span></button>
  </div>

  <div class="modal-overlay">
    <div class="modal-content">
      <div class="modal-message">全てのツイートを削除しますか？</div>
      <div class="modal-buttons">
        <button class="modal-btn" onclick="confirmFlush()">OK</button>
        <button class="modal-btn cancel" onclick="cancelFlush()">Cancel</button>
      </div>
    </div>
  </div>

  <script>
    const { ipcRenderer } = require('electron');
    let tweetArray = [];

    // 編集モード中かどうかを確認する関数
    function isEditing() {
      return document.querySelector('.tweet.editing') !== null;
    }

    // イベントリスナーの設定
    document.addEventListener('DOMContentLoaded', async () => {
      // ツイートの読み込み
      try {
        tweetArray = await ipcRenderer.invoke('load-tweets');
        refreshTweetDisplay(tweetArray);
        
        // ツイート表示後にフォーカス状態を復元（遅延実行）
        setTimeout(() => {
          console.log('Delayed focus state restoration');
          restoreFocusState();
        }, 200);
      } catch (error) {
        console.error('Failed to load tweets:', error);
        showMessage('ツイートの読み込みに失敗しました');
      }

      // 新規ツイート入力欄の設定
      const newTweetElement = document.querySelector('.tweet.new-tweet');
      if (newTweetElement) {
        newTweetElement.addEventListener('click', () => {
          if (!newTweetElement.classList.contains('editing')) {
            enterNewTweetEditMode(newTweetElement);
          }
        });
      }

      // エクスポートボタンのイベントリスナー
      document.getElementById('exportBtn').addEventListener('click', exportTweets);
      
      // JSONエクスポートボタンのイベントリスナー
      document.getElementById('exportJsonBtn').addEventListener('click', exportTweetsAsJson);
      
      // JSONインポートボタンのイベントリスナー
      document.getElementById('importJsonBtn').addEventListener('click', importTweetsFromJson);
      
      // JSONマージボタンのイベントリスナー
      document.getElementById('mergeJsonBtn').addEventListener('click', mergeTweetsFromJson);
      
      // ショートカット表示ボタンのイベントリスナー
      document.getElementById('toggleControlsBtn').addEventListener('click', () => {
        const controls = document.querySelector('.controls-info');
        controls.style.display = controls.style.display === 'none' || controls.style.display === '' ? 'flex' : 'none';
      });
      
      // フォーカスボタンのイベントリスナー
      document.getElementById('focusBtn').addEventListener('click', () => {
        console.log('Focus button clicked');
        // 現在フォーカスされているツイートがない場合は、最初のツイートにフォーカスを移動
        const currentFocus = document.activeElement;
        if (!currentFocus || !currentFocus.classList.contains('tweet') || currentFocus.classList.contains('child-tweet') || currentFocus.classList.contains('new-tweet')) {
          const firstTweet = document.querySelector('.tweet:not(.child-tweet):not(.new-tweet)');
          if (firstTweet) {
            firstTweet.focus();
          }
        }
        
        // フォーカス機能の代わりにマインドフック機能を実行
        toggleMindHookOnTweet();
      });
      
      // 全削除ボタンのイベントリスナー
      document.querySelector('.flush-btn').addEventListener('click', flushTweets);
      
      // モーダルのボタンイベントリスナー
      document.getElementById('confirmFlushBtn').addEventListener('click', confirmFlush);
      document.getElementById('cancelFlushBtn').addEventListener('click', cancelFlush);
    });

    // キーボードショートカットの設定
    document.addEventListener('keydown', (e) => {
      // 編集中の場合はショートカットを無効化
      if (isEditing() && e.key !== 'Escape') {
        return;
      }

      // マインドフック機能のショートカット (f)
      if (!e.ctrlKey && !e.metaKey && !e.altKey && e.key.toLowerCase() === 'f') {
        e.preventDefault();
        console.log('Mind hook shortcut triggered from main listener');
        
        // 現在フォーカスされているツイートがない場合は、最初のツイートにフォーカスを移動
        const currentFocus = document.activeElement;
        if (!currentFocus || (!currentFocus.classList.contains('tweet') && !currentFocus.classList.contains('child-tweet'))) {
          const firstTweet = document.querySelector('.tweet:not(.new-tweet)');
          if (firstTweet) {
            firstTweet.focus();
            console.log('Focus moved to first tweet by shortcut');
          }
        }
        
        // マインドフック機能を実行
        toggleMindHookOnTweet();
        return;
      }

      // 新規ツイート入力 (⌘/Ctrl + N)
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'n') {
        e.preventDefault();
        const newTweetElement = document.querySelector('.tweet.new-tweet');
        if (newTweetElement && !newTweetElement.classList.contains('editing')) {
          enterNewTweetEditMode(newTweetElement);
        }
        return;
      }

      // 選択されたツイートの編集 (iキー)
      if (!e.ctrlKey && !e.metaKey && !e.shiftKey && e.key.toLowerCase() === 'i') {
        e.preventDefault();
        const focusedTweet = document.activeElement;
        if (focusedTweet && focusedTweet.classList.contains('tweet')) {
          if (focusedTweet.classList.contains('child-tweet')) {
            // 子ツイートの編集
            const parentIndex = parseInt(focusedTweet.getAttribute('data-parent-index'));
            const childIndex = parseInt(focusedTweet.getAttribute('data-child-index'));
            if (!isNaN(parentIndex) && !isNaN(childIndex)) {
              editChildTweet(parentIndex, childIndex);
            }
          } else if (!focusedTweet.classList.contains('new-tweet')) {
            // 親ツイートの編集
            const actualIndex = parseInt(focusedTweet.getAttribute('data-actual-index'));
            if (!isNaN(actualIndex)) {
              editTweet(actualIndex);
            }
          }
        }
        return;
      }

      // ツイート間の移動 (j/kキー)
      if (!e.ctrlKey && !e.metaKey && !e.shiftKey && (e.key === 'j' || e.key === 'k')) {
        e.preventDefault();
        const currentFocus = document.activeElement;
        
        if (!currentFocus || !currentFocus.classList.contains('tweet')) {
          // フォーカスがツイートにない場合は最初のツイートにフォーカス
          const firstTweet = document.querySelector('.tweet:not(.new-tweet)');
          if (firstTweet) {
            firstTweet.focus();
          }
          return;
        }
        
        // 表示されているすべてのツイート（親と展開されている子）を取得
        const parentTweets = Array.from(document.querySelectorAll('.tweet:not(.child-tweet):not(.new-tweet)'));
        const expandedChildren = Array.from(document.querySelectorAll('.children-container.expanded .tweet.child-tweet'));
        const visibleTweets = [...parentTweets, ...expandedChildren].sort((a, b) => {
          // DOMでの位置に基づいてソート
          return a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
        });
        
        // 子ツイートが表示されているかどうかを確認
        const hasExpandedChildren = document.querySelector('.children-container.expanded') !== null;
        
        if (hasExpandedChildren) {
          // 子ツイートが表示されている場合は、表示されているすべてのツイート間を移動
          const visibleIndex = visibleTweets.indexOf(currentFocus);
          
          if (e.key === 'j') {
            // 次のツイートへ（自分の子ツイートへ）
            if (visibleIndex < visibleTweets.length - 1) {
              visibleTweets[visibleIndex + 1]?.focus();
            } else {
              // 最後のツイートの場合は最初に戻る
              visibleTweets[0]?.focus();
            }
          } else {
            // 前のツイートへ
            if (visibleIndex > 0) {
              visibleTweets[visibleIndex - 1]?.focus();
            } else {
              // 最初のツイートの場合は最後に移動
              visibleTweets[visibleTweets.length - 1]?.focus();
            }
          }
        } else {
          // 子ツイートが表示されていない場合は、親ツイート間を移動
          const parentTweetIndex = parentTweets.indexOf(currentFocus);
          
          if (e.key === 'j') {
            // 次の親ツイートへ
            if (parentTweetIndex < parentTweets.length - 1) {
              parentTweets[parentTweetIndex + 1]?.focus();
            } else {
              // 最後の親ツイートの場合は最初に戻る
              parentTweets[0]?.focus();
            }
          } else {
            // 前の親ツイートへ
            if (parentTweetIndex > 0) {
              parentTweets[parentTweetIndex - 1]?.focus();
            } else {
              // 最初の親ツイートの場合は最後に移動
              parentTweets[parentTweets.length - 1]?.focus();
            }
          }
        }
        return;
      }

      // ショートカット一覧の表示/非表示 (⌘/Ctrl + ?)
      if ((e.ctrlKey || e.metaKey) && (e.key === '?' || e.key === '/')) {
        e.preventDefault();
        const controls = document.querySelector('.controls-info');
        controls.style.display = controls.style.display === 'none' || controls.style.display === '' ? 'flex' : 'none';
        return;
      }

      // タイマーの開始/停止 (⌘/Ctrl + S)
      if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase() === 's') {
        e.preventDefault(); // デフォルトの保存動作を防ぐ
        toggleTimer();
        return;
      }

      // タイマーのリセット (⌘/Ctrl + Shift + S)
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === 's') {
        e.preventDefault();
        resetTimer();
        return;
      }

      // JSONエクスポート (⌘/Ctrl + Shift + J)
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === 'j') {
        e.preventDefault();
        exportTweetsAsJson();
        return;
      }

      // 新規ツイート入力 (⌘/Ctrl + N)
      if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase() === 'n') {
        e.preventDefault();
        const newTweet = document.querySelector('.tweet.new-tweet');
        if (newTweet) {
          newTweet.focus();
          enterNewTweetEditMode(newTweet);
        }
        return;
      }

      // iキーでツイートを編集
      if (!e.ctrlKey && !e.metaKey && !e.shiftKey && e.key.toLowerCase() === 'i') {
        e.preventDefault();
        const focusedTweet = document.activeElement;
        if (focusedTweet && focusedTweet.classList.contains('tweet')) {
          if (focusedTweet.classList.contains('new-tweet')) {
            enterNewTweetEditMode(focusedTweet);
          } else if (focusedTweet.classList.contains('child-tweet')) {
            // 子ツイートの編集
            const parentIndex = parseInt(focusedTweet.getAttribute('data-parent-index'));
            const childIndex = parseInt(focusedTweet.getAttribute('data-child-index'));
            if (!isNaN(parentIndex) && !isNaN(childIndex)) {
              editChildTweet(parentIndex, childIndex);
            }
          } else {
            // 親ツイートの編集
            const actualIndex = parseInt(focusedTweet.getAttribute('data-actual-index'));
            if (!isNaN(actualIndex)) {
              editTweet(actualIndex);
            }
          }
        }
        return;
      }

      // j,kキーでの移動 - この重複したイベントハンドラを削除します
      if (!e.ctrlKey && !e.metaKey && !e.shiftKey && (e.key === 'j' || e.key === 'k')) {
        e.preventDefault();
        const allTweets = Array.from(document.querySelectorAll('.tweet'));
        const currentFocus = document.activeElement;
        let currentIndex = allTweets.indexOf(currentFocus);

        // 現在のフォーカスがツイート上にない場合は、最初/最後のツイートにフォーカス
        if (currentIndex === -1) {
          if (e.key === 'j') {
            allTweets[0]?.focus();
          } else {
            allTweets[allTweets.length - 1]?.focus();
          }
          return;
        }

        // 現在フォーカスされているのが子ツイートかどうか
        const isChildTweet = currentFocus.classList.contains('child-tweet');
        
        // 親ツイートのみを取得
        const parentTweets = Array.from(document.querySelectorAll('.tweet:not(.child-tweet)'));
        
        // 表示されている子ツイートを含むすべてのツイートを取得
        const visibleTweets = Array.from(document.querySelectorAll('.tweet:not(.child-tweet), .children-container.expanded .tweet.child-tweet'));
        
        if (isChildTweet) {
          // 子ツイートの場合
          const parentIndex = parseInt(currentFocus.getAttribute('data-parent-index'));
          const parentTweet = document.querySelector(`.tweet[data-actual-index="${parentIndex}"]`);
          
          // 親ツイートの子ツイートコンテナが展開されているかチェック
          const childrenContainer = document.querySelector(`.children-container[data-parent-index="${parentIndex}"]`);
          const isExpanded = childrenContainer && childrenContainer.classList.contains('expanded');
          
          if (isExpanded) {
            // 子ツイートが表示されている場合は、表示されているすべてのツイート間を移動
            const visibleIndex = visibleTweets.indexOf(currentFocus);
            
            if (e.key === 'j') {
              // 次のツイートへ
              if (visibleIndex < visibleTweets.length - 1) {
                visibleTweets[visibleIndex + 1]?.focus();
              } else {
                // 最後のツイートの場合は最初に戻る
                visibleTweets[0]?.focus();
              }
            } else {
              // 前のツイートへ
              if (visibleIndex > 0) {
                visibleTweets[visibleIndex - 1]?.focus();
              } else {
                // 最初のツイートの場合は最後に移動
                visibleTweets[visibleTweets.length - 1]?.focus();
              }
            }
          
            // 子ツイートが表示されていない場合は、親ツイート間を移動
            const parentTweetIndex = parentTweets.indexOf(parentTweet);
            
            if (e.key === 'j') {
              // 次の親ツイートへ
              if (parentTweetIndex < parentTweets.length - 1) {
                parentTweets[parentTweetIndex + 1]?.focus();
              } else {
                // 最後の親ツイートの場合は最初に戻る
                parentTweets[0]?.focus();
              }
            } else {
              // 前の親ツイートへ
              if (parentTweetIndex > 0) {
                parentTweets[parentTweetIndex - 1]?.focus();
              } else {
                // 最初の親ツイートの場合は最後に移動
                parentTweets[parentTweets.length - 1]?.focus();
              }
            }
          }
        }
        return;
      }

      // 選択されたツイートの削除 (dキー)
      if (!e.ctrlKey && !e.metaKey && !e.shiftKey && e.key.toLowerCase() === 'd') {
        e.preventDefault();
        const focusedTweet = document.activeElement;
        if (focusedTweet && focusedTweet.classList.contains('tweet')) {
          if (focusedTweet.classList.contains('child-tweet')) {
            // 子ツイートの削除
            const parentIndex = parseInt(focusedTweet.getAttribute('data-parent-index'));
            const childIndex = parseInt(focusedTweet.getAttribute('data-child-index'));
            if (!isNaN(parentIndex) && !isNaN(childIndex)) {
              deleteChildTweet(parentIndex, childIndex);
            }
          } else if (!focusedTweet.classList.contains('new-tweet')) {
            // 親ツイートの削除
            const actualIndex = parseInt(focusedTweet.getAttribute('data-actual-index'));
            if (!isNaN(actualIndex)) {
              deleteTweet(actualIndex);
            }
          }
        }
        return;
      }

      // rキーで選択されたツイートに返信（子ツイート追加）
      if (!e.ctrlKey && !e.metaKey && !e.shiftKey && e.key.toLowerCase() === 'o') {
        e.preventDefault();
        const focusedTweet = document.activeElement;
        if (focusedTweet && focusedTweet.classList.contains('tweet') && !focusedTweet.classList.contains('new-tweet') && !focusedTweet.classList.contains('child-tweet')) {
          const actualIndex = parseInt(focusedTweet.getAttribute('data-actual-index'));
          if (!isNaN(actualIndex)) {
            addChildTweet(actualIndex);
          }
        }
        return;
      }

      // トグルボタン機能（スペースキー）
      if (!e.ctrlKey && !e.metaKey && !e.shiftKey && e.key === ' ') {
        e.preventDefault();
        const focusedTweet = document.activeElement;
        if (focusedTweet && focusedTweet.classList.contains('tweet') && !focusedTweet.classList.contains('child-tweet') && !focusedTweet.classList.contains('new-tweet')) {
          const actualIndex = parseInt(focusedTweet.getAttribute('data-actual-index'));
          if (!isNaN(actualIndex)) {
            toggleChildrenVisibility(actualIndex);
          }
        }
        return;
      }
    });

    const tweetEffects = [
      {
        name: 'matrix-effect',
        duration: 1000
      }
    ];

    async function postTweet(content) {
      if (content) {
        const newTweet = {
          content: content.replace(/\n/g, '<br>'),
          timestamp: new Date().toISOString(),
          children: [] // 子ツイート配列を初期化
        };

        try {
          // まず永続化を試みる
          tweetArray.push(newTweet);
          await ipcRenderer.invoke('save-tweets', tweetArray);

          // 永続化成功後にUIを更新
          const actualIndex = tweetArray.length - 1; // 新しいツイートの実際のインデックス
          const tweet = createTweetElement(newTweet, 0, actualIndex);
          
          // 新規ツイート入力欄の後に挿入
          const newTweetElement = document.querySelector('.tweet.new-tweet');
          if (newTweetElement && newTweetElement.nextSibling) {
            document.getElementById('tweets').insertBefore(tweet, newTweetElement.nextSibling);
          } else {
            // フォールバック: 新規ツイート入力欄が見つからない場合は先頭に追加
            document.getElementById('tweets').prepend(tweet);
          }

          // 既存のツイートのインデックスを更新
          const existingTweets = document.querySelectorAll('.tweet:not(.new-tweet):not(.child-tweet)');
          existingTweets.forEach(existingTweet => {
            // 新しく追加したツイート以外のインデックスを更新
            if (existingTweet !== tweet) {
              const oldIndex = parseInt(existingTweet.getAttribute('data-index'));
              existingTweet.setAttribute('data-index', oldIndex + 1);
            }
          });

          // マトリックスエフェクトを適用
          tweet.classList.add('matrix-effect');
          setTimeout(() => {
            tweet.classList.remove('matrix-effect');
          }, 1000);

          return true;
        } catch (error) {
          console.error('Failed to save tweet:', error);
          // エラーが発生した場合、配列から削除して元に戻す
          tweetArray.pop();
          throw error;
        }
      }
      return false;
    }

    function formatTime(timestamp) {
      const date = new Date(timestamp);
      const now = new Date();
      const diffMinutes = Math.floor((now - date) / (1000 * 60));

      // 1分未満は「NOW」と表示
      if (diffMinutes < 1) return 'NOW';
      
      // 日付と時刻を「mm/dd hh:mm」形式でフォーマット
      const month = (date.getMonth() + 1).toString().padStart(2, '0');
      const day = date.getDate().toString().padStart(2, '0');
      const hours = date.getHours().toString().padStart(2, '0');
      const minutes = date.getMinutes().toString().padStart(2, '0');
      
      return `${month}/${day} ${hours}:${minutes}`;
    }

    let timer;
    let startTime;
    let accumulatedTime = 0;
    let running = false;

    const coolMessages = [
      "Data has been launched into the cosmos 🚀",
      "Your words are now beyond infinity!",
      "The Enter key can't believe this!",
      "This moment has changed the world!",
      "Magic of coding unleashed!",
      "Information has transcended dimensions!",
      "This copy is rare indeed!",
      "Invincible paste ready!",
      "Text is transcending dimensions!",
      "Data races through the network!",
      "This copy will go down in history!",
      "Your message shines brightly!",
      "Copy complete, grand departure!",
      "Astonishing coding power!",
      "First step into uncharted territory!",
      "Thought has been materialized!",
      "Data races through time and space!",
      "Information moving at light speed!",
      "Everyone praises this copy!",
      "Legendary copy complete!",
      "Your input is now reaching the future!",
      "Inspiration is unstoppable!",
      "Infinite possibilities take flight!",
      "The best copy, surprising the world!",
      "Imagination has been digitized!",
      "The future awaits you!",
      "This text is art at heart!",
      "Information moving like lightning!",
      "Message has soared into the universe!",
      "Input complete, infinite possibilities ahead!"
    ];

    function autoResize(elem) {
      const minHeight = 80; // 最小の高さも80pxに

      // スクロールの高さを正確に計測するための一時的な高さリセット
      elem.style.height = 'auto';

      // 実際のコンテンツの高さを取得（最小値は保持）
      const newHeight = Math.max(elem.scrollHeight, minHeight);

      // 現在の高さと新しい高さが異なる場合のみ更新
      if (elem.clientHeight !== newHeight) {
        elem.style.height = newHeight + 'px';
      }
    }

    function updateTimerDisplay() {
      if (!running && accumulatedTime === 0) {
        document.querySelector('#timerDisplay .time').textContent = "Click to Start";
        return;
      }
      const elapsed = Math.floor((Date.now() - startTime + accumulatedTime) / 1000);
      const hours = Math.floor(elapsed / 3600);
      const minutes = Math.floor((elapsed % 3600) / 60);
      const seconds = elapsed % 60;
      document.querySelector('#timerDisplay .time').textContent =
          `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    async function copyToClipboard() {
      try {
        await navigator.clipboard.writeText(taskInput);
        const message = coolMessages[Math.floor(Math.random() * coolMessages.length)];
        showMessage(message);
      } catch (err) {
        console.error('Failed to copy to clipboard:', err);
      }
    }

    function showMessage(text) {
      const messageDiv = document.getElementById('message');
      messageDiv.textContent = text;
      messageDiv.style.display = 'block';
      setTimeout(() => {
        messageDiv.style.display = 'none';
      }, 3000);
    }

    function toggleTimer() {
      if (running) {
        stopTimer();
      } else {
        startTimer();
      }
    }

    function startTimer() {
      if (!running) {
        running = true;
        startTime = Date.now();
        timer = setInterval(updateTimerDisplay, 1000);
        updateTimerDisplay();
        document.getElementById('timerDisplay').classList.add('running');
        document.querySelector('.timer-button.play-pause').textContent = '⏸';
      }
    }

    function stopTimer() {
      if (running) {
        running = false;
        clearInterval(timer);
        accumulatedTime += Date.now() - startTime;
        document.getElementById('timerDisplay').classList.remove('running');
        document.querySelector('.timer-button.play-pause').textContent = '▶';
      }
    }

    function resetTimer() {
      running = false;
      clearInterval(timer);
      accumulatedTime = 0
      document.querySelector('#timerDisplay .time').textContent = "00:00:00";
      document.getElementById('timerDisplay').classList.remove('running');
      document.querySelector('.timer-button.play-pause').textContent = '▶';
    }

    // タイマーディスプレイのクリックイベントを追加
    document.querySelector('#timerDisplay .time').addEventListener('click', function(e) {
      toggleTimer();
    });

    async function exportTweets() {
      try {
        let exportText = '';
        
        // ツイートを新しい順に処理
        for (let i = tweetArray.length - 1; i >= 0; i--) {
          const tweet = tweetArray[i];
          
          // 親ツイートの内容と時間を追加
          const tweetDate = new Date(tweet.timestamp);
          const tweetDateStr = tweetDate.toLocaleString('ja-JP');
          exportText += `${tweetDateStr}  ${tweet.content.replace(/<br>/g, '\n')}\n\n`;
          
          // 子ツイートがあれば追加
          if (tweet.children && tweet.children.length > 0) {
            tweet.children.forEach(childTweet => {
              // 子ツイートの時間とコンテンツを追加
              const childDate = new Date(childTweet.timestamp);
              const childDateStr = childDate.toLocaleString('ja-JP');
              exportText += `\t${childDateStr}  ${childTweet.content.replace(/<br>/g, '\n').replace(/\n/g, '\n\t')}\n\n`;
            });
          }
        }
        
        // クリップボードにコピー - 改善版
        try {
          // 非同期APIを使用
          await navigator.clipboard.writeText(exportText);
          showMessage('エクスポートに成功しました。');
        } catch (clipboardErr) {
          console.error('クリップボードAPIエラー:', clipboardErr);
          
          // フォールバック: 一時的なテキストエリアを使用
          const textArea = document.createElement('textarea');
          textArea.value = exportText;
          textArea.style.position = 'fixed';
          textArea.style.left = '-999999px';
          textArea.style.top = '-999999px';
          document.body.appendChild(textArea);
          textArea.focus();
          textArea.select();
          
          try {
            const successful = document.execCommand('copy');
            if (successful) {
              showMessage('エクスポートに成功しました。');
            } else {
              throw new Error('execCommand copy failed');
            }
          } catch (execErr) {
            console.error('execCommand エラー:', execErr);
            alert('クリップボードへのコピーに失敗しました。');
          } finally {
            document.body.removeChild(textArea);
          }
        }
      } catch (error) {
        console.error('エクスポートエラー:', error);
        alert('エクスポートに失敗しました。');
      }
    }

    // JSONエクスポート機能
    async function exportTweetsAsJson() {
      try {
        const tweets = await ipcRenderer.invoke('export-tweets-json');
        if (tweets.length === 0) {
          alert('エクスポートするツイートがありません。');
          return;
        }

        // JSONデータを作成
        const jsonData = JSON.stringify(tweets, null, 2);
        
        // Blobを作成
        const blob = new Blob([jsonData], { type: 'application/json' });
        
        // ダウンロードリンクを作成
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        
        // 現在の日時をファイル名に含める
        const now = new Date();
        const dateStr = now.toISOString().replace(/[:.]/g, '-').replace('T', '_').split('Z')[0];
        a.download = `mind_clock_export_${dateStr}.json`;
        
        
        // リンクをクリックしてダウンロード
        document.body.appendChild(a);
        a.click();
        
        // クリーンアップ
        setTimeout(() => {
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }, 100);
        
        showMessage('JSONファイルがエクスポートされました！');
      } catch (error) {
        console.error('JSONエクスポートエラー:', error);
        alert(`エクスポート中にエラーが発生しました: ${error.message}`);
      }
    }

    // JSONインポート機能
    async function importTweetsFromJson() {
      try {
        // ファイル選択ダイアログを表示
        const fileInput = document.getElementById('jsonFileInput');
        fileInput.onchange = async (event) => {
          const file = event.target.files[0];
          if (!file) return;
          
          const reader = new FileReader();
          reader.onload = async (e) => {
            try {
              const jsonData = JSON.parse(e.target.result);
              
              // 確認ダイアログを表示
              if (confirm('現在のデータを上書きしますか？キャンセルを選択すると、マージモードになります。')) {
                // インポート（上書き）
                const importedTweets = await ipcRenderer.invoke('import-tweets-json', jsonData);
                refreshTweetDisplay(importedTweets);
                showMessage('JSONデータがインポートされました！');
              } else {
                // マージ
                const mergedTweets = await ipcRenderer.invoke('merge-tweets-json', jsonData);
                refreshTweetDisplay(mergedTweets);
                showMessage('JSONデータがマージされました！');
              }
            } catch (error) {
              console.error('JSONパースエラー:', error);
              alert(`JSONファイルの解析中にエラーが発生しました: ${error.message}`);
            }
            
            // ファイル入力をリセット
            fileInput.value = '';
          };
          reader.readAsText(file);
        };
        
        fileInput.click();
      } catch (error) {
        console.error('JSONインポートエラー:', error);
        alert(`インポート中にエラーが発生しました: ${error.message}`);
      }
    }

    // JSONマージ機能
    async function mergeTweetsFromJson() {
      try {
        // ファイル選択ダイアログを表示
        const fileInput = document.getElementById('jsonFileInput');
        fileInput.onchange = async (event) => {
          const file = event.target.files[0];
          if (!file) return;
          
          const reader = new FileReader();
          reader.onload = async (e) => {
            try {
              const jsonData = JSON.parse(e.target.result);
              
              // マージ処理
              const mergedTweets = await ipcRenderer.invoke('merge-tweets-json', jsonData);
              refreshTweetDisplay(mergedTweets);
              showMessage('JSONデータがマージされました！');
            } catch (error) {
              console.error('JSONパースエラー:', error);
              alert(`JSONファイルの解析中にエラーが発生しました: ${error.message}`);
            }
            
            // ファイル入力をリセット
            fileInput.value = '';
          };
          reader.readAsText(file);
        };
        
        fileInput.click();
      } catch (error) {
        console.error('JSONマージエラー:', error);
        alert(`マージ中にエラーが発生しました: ${error.message}`);
      }
    }

    // ツイート表示を更新する共通関数
    function refreshTweetDisplay(tweets) {
      tweetArray = tweets;
      const tweetsContainer = document.getElementById('tweets');
      tweetsContainer.innerHTML = '';
      
      // 新規ツイート入力欄を追加（最初に）
      const newTweetElement = document.createElement('div');
      newTweetElement.className = 'tweet new-tweet';
      newTweetElement.setAttribute('tabindex', '0');
      newTweetElement.innerHTML = `
        <span class="content">Initialize thought sequence...</span>
      `;
      tweetsContainer.appendChild(newTweetElement);
      
      // 新規ツイート入力欄のクリックイベントを設定
      newTweetElement.addEventListener('click', () => {
        if (!newTweetElement.classList.contains('editing')) {
          enterNewTweetEditMode(newTweetElement);
        }
      });
      
      // ツイートを表示（新しい順）
      for (let idx = 0; idx < tweetArray.length; idx++) {
        const tweetIndex = tweetArray.length - 1 - idx; // 表示順序は逆だが、実際のインデックスを使用
        const tweet = tweetArray[tweetIndex];
        
        // 親ツイートを作成
        const tweetElement = createTweetElement(tweet, idx, tweetIndex);
        tweetsContainer.appendChild(tweetElement);
        
        // 子ツイートがある場合は子ツイートコンテナを作成
        if (tweet.children && tweet.children.length > 0) {
          const childrenContainer = document.createElement('div');
          childrenContainer.className = 'children-container expanded'; // 基本的に表示状態にする
          childrenContainer.setAttribute('data-parent-index', tweetIndex);
          
          // 子ツイートを表示
          tweet.children.forEach((childTweet, childIdx) => {
            const childElement = createChildTweetElement(childTweet, childIdx, tweetIndex);
            childrenContainer.appendChild(childElement);
          });
          
          // 子ツイートコンテナを親ツイートの後に追加
          tweetsContainer.insertBefore(childrenContainer, tweetElement.nextSibling);
          
          // 親ツイートに子ツイートがあることを示すインジケータを追加
          const hasChildrenIndicator = document.createElement('span');
          hasChildrenIndicator.className = 'has-children-indicator';
          hasChildrenIndicator.textContent = '▼'; // 基本的に開いた状態
          hasChildrenIndicator.setAttribute('title', '子ツイートを表示/非表示');
          hasChildrenIndicator.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleChildrenVisibility(tweetIndex);
          });
          
          // インジケータを親ツイートのコンテンツの前に追加
          const contentSpan = tweetElement.querySelector('.content');
          tweetElement.insertBefore(hasChildrenIndicator, contentSpan);
        }
      }
      
      console.log('Refreshed tweet display, now restoring focus state');
      
      // ツイート表示後にフォーカス状態を復元
      setTimeout(() => {
        restoreFocusState();
      }, 100);
    }

    // 親ツイート要素を作成する関数
    function createTweetElement(tweet, displayIndex, actualIndex) {
      const tweetElement = document.createElement('div');
      tweetElement.className = 'tweet';
      tweetElement.setAttribute('data-text', tweet.content);
      tweetElement.setAttribute('data-index', displayIndex); // 表示順のインデックスを設定（0から始まる）
      tweetElement.setAttribute('data-actual-index', actualIndex); // 実際のデータ配列のインデックスも保存
      tweetElement.setAttribute('tabindex', '0');
      
      // コンテンツと時間を別々に作成して追加
      const contentSpan = document.createElement('span');
      contentSpan.className = 'content';
      contentSpan.innerHTML = tweet.content; // innerHTMLを使用して<br>タグを正しく解釈
      
      const timeSpan = document.createElement('span');
      timeSpan.className = 'time';
      timeSpan.textContent = formatTime(tweet.timestamp);
      
      // アクションボタンを追加
      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'tweet-actions';
      
      // 返信ボタン
      const replyButton = document.createElement('span');
      replyButton.className = 'tweet-action reply-action';
      replyButton.textContent = '↩';
      replyButton.setAttribute('title', '返信する');
      replyButton.addEventListener('click', (e) => {
        e.stopPropagation();
        addChildTweet(actualIndex);
      });
      
      actionsDiv.appendChild(replyButton);
      
      tweetElement.appendChild(contentSpan);
      tweetElement.appendChild(actionsDiv);
      tweetElement.appendChild(timeSpan);
      
      return tweetElement;
    }

    // 子ツイート要素を作成する関数
    function createChildTweetElement(childTweet, childIndex, parentIndex) {
      const childElement = document.createElement('div');
      childElement.className = 'tweet child-tweet';
      childElement.setAttribute('data-text', childTweet.content);
      childElement.setAttribute('data-child-index', childIndex);
      childElement.setAttribute('data-parent-index', parentIndex);
      childElement.setAttribute('tabindex', '0');
      
      // 子ツイートのインジケータ
      const childIndicator = document.createElement('span');
      childIndicator.className = 'child-indicator';
      childIndicator.textContent = '↪';
      
      // コンテンツと時間を別々に作成して追加
      const contentSpan = document.createElement('span');
      contentSpan.className = 'content';
      contentSpan.innerHTML = childTweet.content;
      
      const timeSpan = document.createElement('span');
      timeSpan.className = 'time';
      timeSpan.textContent = formatTime(childTweet.timestamp);
      
      childElement.appendChild(childIndicator);
      childElement.appendChild(contentSpan);
      childElement.appendChild(timeSpan);
      
      return childElement;
    }

    // 子ツイートの表示/非表示を切り替える関数
    function toggleChildrenVisibility(parentIndex) {
      const childrenContainer = document.querySelector(`.children-container[data-parent-index="${parentIndex}"]`);
      if (childrenContainer) {
        childrenContainer.classList.toggle('expanded');
        
        // インジケータの向きを変更
        const parentTweet = document.querySelector(`.tweet[data-actual-index="${parentIndex}"]`);
        const indicator = parentTweet.querySelector('.has-children-indicator');
        if (indicator) {
          indicator.textContent = childrenContainer.classList.contains('expanded') ? '▼' : '▶';
        }
      }
    }

    // 子ツイートを追加する関数
    async function addChildTweet(parentIndex) {
      const parentTweet = document.querySelector(`.tweet[data-actual-index="${parentIndex}"]`);
      if (!parentTweet) return;
      
      // 子ツイート入力用の要素を作成
      const childInputElement = document.createElement('div');
      childInputElement.className = 'tweet child-tweet editing';
      childInputElement.setAttribute('data-parent-index', parentIndex);
      
      // 子ツイートのインジケータ
      const childIndicator = document.createElement('span');
      childIndicator.className = 'child-indicator';
      childIndicator.textContent = '↪';
      
      // 編集可能なコンテンツ要素
      const contentSpan = document.createElement('span');
      contentSpan.className = 'content';
      contentSpan.contentEditable = true;
      contentSpan.textContent = '';
      
      childInputElement.appendChild(childIndicator);
      childInputElement.appendChild(contentSpan);
      
      // 子ツイートコンテナを取得または作成
      let childrenContainer = document.querySelector(`.children-container[data-parent-index="${parentIndex}"]`);
      if (!childrenContainer) {
        childrenContainer = document.createElement('div');
        childrenContainer.className = 'children-container';
        childrenContainer.setAttribute('data-parent-index', parentIndex);
        
        // 親ツイートの後に子ツイートコンテナを挿入
        parentTweet.parentNode.insertBefore(childrenContainer, parentTweet.nextSibling);
        
        // 親ツイートに子ツイートがあることを示すインジケータを追加（まだなければ）
        if (!parentTweet.querySelector('.has-children-indicator')) {
          const hasChildrenIndicator = document.createElement('span');
          hasChildrenIndicator.className = 'has-children-indicator';
          hasChildrenIndicator.textContent = '▶';
          hasChildrenIndicator.setAttribute('title', '子ツイートを表示/非表示');
          hasChildrenIndicator.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleChildrenVisibility(parentIndex);
          });
          
          // インジケータを親ツイートのコンテンツの前に追加
          const contentSpan = parentTweet.querySelector('.content');
          parentTweet.insertBefore(hasChildrenIndicator, contentSpan);
        }
      }
      
      // 子ツイートコンテナを表示
      childrenContainer.classList.add('expanded');
      
      // インジケータの向きを変更
      const indicator = parentTweet.querySelector('.has-children-indicator');
      if (indicator) {
        indicator.textContent = '▼';
      }
      
      // 子ツイート入力要素を子ツイートコンテナの先頭に追加
      childrenContainer.insertBefore(childInputElement, childrenContainer.firstChild);
      
      // フォーカスを設定
      contentSpan.focus();
      
      // IME入力状態を追跡
      let isComposing = false;
      
      // IME入力開始イベントのリスナー
      const handleCompositionStart = () => {
        isComposing = true;
      };
      
      // IME入力終了イベントのリスナー
      const handleCompositionEnd = () => {
        isComposing = false;
      };
      
      // 編集完了のイベントリスナー
      const handleEditKeypress = async (e) => {
        // cmd + enterで保存
        if (e.key === 'Enter' && (e.metaKey || e.ctrlKey) && !isComposing) {
          e.preventDefault();
          e.stopPropagation();
          const newContent = contentSpan.textContent.trim();
          
          if (newContent) {
            try {
              // 子ツイートを追加
              const childTweet = {
                content: newContent.replace(/\n/g, '<br>'),
                timestamp: new Date().toISOString()
              };
              
              // バックエンドに子ツイートを追加
              tweetArray = await ipcRenderer.invoke('add-child-tweet', parentIndex, childTweet);
              
              // 編集モードを終了
              finishEditing();
              
              // ツイート一覧を再描画
              refreshTweetDisplay(tweetArray);
            } catch (error) {
              console.error('Failed to add child tweet:', error);
              finishEditing();
            }
          } else {
            finishEditing();
          }
        } else if (e.key === 'Escape') {
          // 編集をキャンセル
          e.preventDefault();
          e.stopPropagation();
          finishEditing();
        }
      };
      
      // 編集モード終了時の共通処理
      const finishEditing = () => {
        document.removeEventListener('keydown', handleEditKeypress);
        contentSpan.removeEventListener('compositionstart', handleCompositionStart);
        contentSpan.removeEventListener('compositionend', handleCompositionEnd);
        
        // 入力要素を削除
        if (childInputElement.parentNode) {
          childInputElement.parentNode.removeChild(childInputElement);
        }
        
        // 子ツイートがない場合は子ツイートコンテナとインジケータを削除
        const existingChildTweets = childrenContainer.querySelectorAll('.tweet.child-tweet:not(.editing)');
        if (existingChildTweets.length === 0) {
          // 子ツイートコンテナを削除
          if (childrenContainer.parentNode) {
            childrenContainer.parentNode.removeChild(childrenContainer);
          }
          
          // インジケータを削除
          if (indicator) {
            indicator.parentNode.removeChild(indicator);
          }
        }
      };
      
      // イベントリスナーを追加
      document.addEventListener('keydown', handleEditKeypress);
      contentSpan.addEventListener('compositionstart', handleCompositionStart);
      contentSpan.addEventListener('compositionend', handleCompositionEnd);
    }

    // 子ツイートを編集する関数
    async function editChildTweet(parentIndex, childIndex) {
      const childTweet = document.querySelector(`.tweet.child-tweet[data-parent-index="${parentIndex}"][data-child-index="${childIndex}"]`);
      if (!childTweet) return;
      
      const contentSpan = childTweet.querySelector('.content');
      const originalContent = contentSpan.innerHTML.replace(/<br>/g, '\n');
      let isComposing = false;
      
      // 編集モードに入る
      childTweet.classList.add('editing');
      contentSpan.contentEditable = true;
      contentSpan.textContent = originalContent;
      contentSpan.focus();
      
      // IME入力開始イベントのリスナー
      const handleCompositionStart = () => {
        isComposing = true;
      };
      
      // IME入力終了イベントのリスナー
      const handleCompositionEnd = () => {
        isComposing = false;
      };
      
      // 編集完了のイベントリスナー
      const handleEditKeypress = async (e) => {
        // cmd + enterで保存
        if (e.key === 'Enter' && (e.metaKey || e.ctrlKey) && !isComposing) {
          e.preventDefault();
          e.stopPropagation();
          const newContent = contentSpan.textContent.trim();
          
          if (newContent !== originalContent) {
            try {
              // 子ツイートの内容を更新
              tweetArray = await ipcRenderer.invoke('edit-child-tweet', parentIndex, childIndex, newContent.replace(/\n/g, '<br>'));
              
              // 表示を更新
              contentSpan.innerHTML = newContent.replace(/\n/g, '<br>');
              contentSpan.contentEditable = false;
              childTweet.classList.remove('editing');
              childTweet.focus();
            } catch (error) {
              console.error('Failed to edit child tweet:', error);
              // エラー時は元の内容に戻す
              contentSpan.innerHTML = originalContent;
              finishEditing();
            }
          } else {
            finishEditing();
          }
        } else if (e.key === 'Escape') {
          // 編集をキャンセル
          e.preventDefault();
          e.stopPropagation();
          contentSpan.innerHTML = originalContent;
          finishEditing();
        }
      };
      
      // 編集モード終了時の共通処理
      const finishEditing = () => {
        contentSpan.contentEditable = false;
        childTweet.classList.remove('editing');
        childTweet.focus();
        document.removeEventListener('keydown', handleEditKeypress);
        contentSpan.removeEventListener('compositionstart', handleCompositionStart);
        contentSpan.removeEventListener('compositionend', handleCompositionEnd);
      };
      
      // イベントリスナーを追加
      document.addEventListener('keydown', handleEditKeypress);
      contentSpan.addEventListener('compositionstart', handleCompositionStart);
      contentSpan.addEventListener('compositionend', handleCompositionEnd);
    }

    // 子ツイートを削除する関数
    async function deleteChildTweet(parentIndex, childIndex) {
      const childTweet = document.querySelector(`.tweet.child-tweet[data-parent-index="${parentIndex}"][data-child-index="${childIndex}"]`);
      if (!childTweet) {
        console.error('Child tweet element not found');
        return;
      }
      
      if (!childTweet.classList.contains('confirm')) {
        // 最初の確認時
        childTweet.classList.add('confirm');
        childTweet.style.background = 'rgba(255, 0, 0, 0.1)';
        
        // キーボードイベントリスナーを追加
        const handleDeleteKeypress = async (e) => {
          if (e.key === 'Enter') {
            // Enterキーで削除実行
            document.removeEventListener('keydown', handleDeleteKeypress);
            document.removeEventListener('focusin', handleOtherFocus);
            
            try {
              // 削除前の状態を保存
              const tweetBackup = [...tweetArray];
              
              // 子ツイートを削除
              tweetArray = await ipcRenderer.invoke('delete-child-tweet', parentIndex, childIndex);
              
              // ツイート一覧を再描画
              refreshTweetDisplay(tweetArray);
              
              // 削除成功のメッセージを表示
              showMessage('子ツイートを削除しました');
            } catch (error) {
              console.error('Failed to delete child tweet:', error);
              
              // エラーが発生した場合は元の状態に戻す
              tweetArray = tweetBackup;
              refreshTweetDisplay(tweetArray);
              
              // エラーメッセージを表示
              showMessage('子ツイートの削除に失敗しました');
            }
          } else if (e.key === 'Escape') {
            // Escキーでキャンセル
            document.removeEventListener('keydown', handleDeleteKeypress);
            document.removeEventListener('focusin', handleOtherFocus);
            childTweet.classList.remove('confirm');
            childTweet.style.background = '';
          }
        };
        
        document.addEventListener('keydown', handleDeleteKeypress);
        
        // 他のツイートがフォーカスされた時のイベントリスナー
        const handleOtherFocus = (e) => {
          if (e.target.classList.contains('tweet') && e.target !== childTweet) {
            document.removeEventListener('keydown', handleDeleteKeypress);
            document.removeEventListener('focusin', handleOtherFocus);
            childTweet.classList.remove('confirm');
            childTweet.style.background = '';
          }
        };
        
        document.addEventListener('focusin', handleOtherFocus);
      }
    }

    async function deleteTweet(index) {
      const focusedTweet = document.activeElement;
      if (!focusedTweet || !focusedTweet.classList.contains('tweet')) return;
      
      // data-actual-index属性から実際のデータ配列内のインデックスを取得
      const actualIndex = parseInt(focusedTweet.getAttribute('data-actual-index'));
      if (isNaN(actualIndex)) {
        console.error('Invalid tweet index');
        return;
      }
      
      if (!focusedTweet.classList.contains('confirm')) {
        // 最初の確認時
        focusedTweet.classList.add('confirm');
        focusedTweet.style.background = 'rgba(255, 0, 0, 0.1)';
        
        // キーボードイベントリスナーを追加
        const handleDeleteKeypress = async (e) => {
          if (e.key === 'Enter') {
            // Enterキーで削除実行
            document.removeEventListener('keydown', handleDeleteKeypress);
            document.removeEventListener('focusin', handleOtherFocus);
            await executeDelete(actualIndex);
          } else if (e.key === 'Escape') {
            // Escキーでキャンセル
            document.removeEventListener('keydown', handleDeleteKeypress);
            document.removeEventListener('focusin', handleOtherFocus);
            focusedTweet.classList.remove('confirm');
            focusedTweet.style.background = '';
          }
        };
        
        document.addEventListener('keydown', handleDeleteKeypress);
        
        // 他のツイートがフォーカスされた時のイベントリスナー
        const handleOtherFocus = (e) => {
          if (e.target.classList.contains('tweet') && e.target !== focusedTweet) {
            document.removeEventListener('keydown', handleDeleteKeypress);
            document.removeEventListener('focusin', handleOtherFocus);
            focusedTweet.classList.remove('confirm');
            focusedTweet.style.background = '';
          }
        };
        
        document.addEventListener('focusin', handleOtherFocus);
        
        return;
      }
    }

    async function executeDelete(index) {
      try {
        // フォーカスされているツイート要素を取得
        const focusedTweet = document.activeElement;
        if (!focusedTweet || !focusedTweet.classList.contains('tweet')) {
          console.error('No tweet focused for deletion');
          return;
        }
        
        // data-actual-index属性から実際のデータ配列内のインデックスを取得
        const actualIndex = parseInt(focusedTweet.getAttribute('data-actual-index'));
        
        if (isNaN(actualIndex)) {
          console.error('Invalid tweet index');
          return;
        }

        // 削除前の状態を保存
        const tweetBackup = [...tweetArray];
        
        try {
          // ツイートを削除
          tweetArray = await ipcRenderer.invoke('delete-tweet', actualIndex);
          
          // ツイート一覧を再描画
          refreshTweetDisplay(tweetArray);
          
          // 削除成功のメッセージを表示
          showMessage('ツイートを削除しました');
        } catch (error) {
          console.error('Failed to delete tweet:', error);
          
          // エラーが発生した場合は元の状態に戻す
          tweetArray = tweetBackup;
          refreshTweetDisplay(tweetArray);
          
          // エラーメッセージを表示
          showMessage('ツイートの削除に失敗しました');
        }
      } catch (error) {
        console.error('Error in executeDelete:', error);
        showMessage('予期せぬエラーが発生しました');
      }
    }

    async function flushTweets() {
      showModal();
    }

    function showModal() {
      document.querySelector('.modal-overlay').style.display = 'block';
      // モーダル表示時のキーボードイベントリスナーを追加
      document.addEventListener('keydown', handleModalKeypress);
    }

    function hideModal() {
      document.querySelector('.modal-overlay').style.display = 'none';
      // モーダル非表示時のキーボードイベントリスナーを削除
      document.removeEventListener('keydown', handleModalKeypress);
    }

    function handleModalKeypress(e) {
      if (e.key === 'Enter') {
        confirmFlush();
      } else if (e.key === 'Escape') {
        cancelFlush();
      }
    }

    async function confirmFlush() {
      hideModal();
      try {
        tweetArray = await ipcRenderer.invoke('flush-tweets');
        document.getElementById('tweets').innerHTML = '';
      } catch (error) {
        console.error('Failed to flush tweets:', error);
      }
    }

    function cancelFlush() {
      hideModal();
    }

    async function editTweet(index) {
      const focusedTweet = document.activeElement;
      if (!focusedTweet || !focusedTweet.classList.contains('tweet')) return;
      
      // data-actual-index属性から実際のデータ配列内のインデックスを取得
      const actualIndex = parseInt(focusedTweet.getAttribute('data-actual-index'));
      if (isNaN(actualIndex)) {
        console.error('Invalid tweet index');
        return;
      }
      
      const contentSpan = focusedTweet.querySelector('.content');
      const originalContent = contentSpan.innerHTML.replace(/<br>/g, '\n');
      let isComposing = false;
      
      // 編集モードに入る
      focusedTweet.classList.add('editing');
      contentSpan.contentEditable = true;
      contentSpan.textContent = originalContent;
      contentSpan.focus();

      // IME入力開始イベントのリスナー
      const handleCompositionStart = () => {
        isComposing = true;
      };

      // IME入力終了イベントのリスナー
      const handleCompositionEnd = () => {
        isComposing = false;
      };
      
      // 編集完了のイベントリスナー
      const handleEditKeypress = async (e) => {
        // cmd + enterで保存
        if (e.key === 'Enter' && (e.metaKey || e.ctrlKey) && !isComposing) {
          e.preventDefault();
          e.stopPropagation();
          const newContent = contentSpan.textContent.trim();

          if (newContent !== originalContent) {
            // ツイートの内容を更新
            tweetArray[actualIndex].content = newContent.replace(/\n/g, '<br>');

            // 保存
            try {
              await ipcRenderer.invoke('save-tweets', tweetArray);
              // 表示を更新
              focusedTweet.setAttribute('data-text', newContent);
              contentSpan.innerHTML = newContent.replace(/\n/g, '<br>');
              contentSpan.contentEditable = false;
              focusedTweet.classList.remove('editing');
              focusedTweet.focus();
            } catch (error) {
              console.error('Failed to save edited tweet:', error);
              // エラー時は元の内容に戻す
              contentSpan.innerHTML = originalContent;
              finishEditing();
            }
          } else {
            finishEditing();
          }
        } else if (e.key === 'Escape') {
          // 編集をキャンセル
          e.preventDefault();
          e.stopPropagation();
          contentSpan.innerHTML = originalContent;
          finishEditing();
        }
      };

      // 編集モード終了時の共通処理
      const finishEditing = () => {
        contentSpan.contentEditable = false;
        focusedTweet.classList.remove('editing');
        focusedTweet.focus();
        document.removeEventListener('keydown', handleEditKeypress);
        contentSpan.removeEventListener('compositionstart', handleCompositionStart);
        contentSpan.removeEventListener('compositionend', handleCompositionEnd);
      };
      
      // イベントリスナーを追加
      document.addEventListener('keydown', handleEditKeypress);
      contentSpan.addEventListener('compositionstart', handleCompositionStart);
      contentSpan.addEventListener('compositionend', handleCompositionEnd);
    }

    // 新規ツイート入力モードに入る処理
    function enterNewTweetEditMode(tweetElement) {
      const contentSpan = tweetElement.querySelector('.content');
      let isComposing = false;

      // プレースホルダーテキストをクリア
      if (contentSpan.textContent === 'Initialize thought sequence...') {
        contentSpan.textContent = '';
      }

      // 編集モードに入る
      tweetElement.classList.add('editing');
      contentSpan.contentEditable = true;
      contentSpan.focus();

      // IME入力開始イベントのリスナー
      const handleCompositionStart = () => {
        isComposing = true;
      };

      // IME入力終了イベントのリスナー
      const handleCompositionEnd = () => {
        isComposing = false;
      };

      // 編集完了のイベントリスナー
      const handleEditKeypress = async (e) => {
        // cmd + enterで投稿
        if (e.key === 'Enter' && (e.metaKey || e.ctrlKey) && !isComposing) {
          e.preventDefault();
          e.stopPropagation();
          const newContent = contentSpan.textContent.trim();

          if (newContent) {
            try {
              // ツイートを投稿
              await postTweet(newContent);
              // 入力欄をリセット
              contentSpan.textContent = '';
              contentSpan.focus();
            } catch (error) {
              console.error('Failed to post tweet:', error);
              showMessage('ツイートの投稿に失敗しました');
            }
          } else {
            finishNewTweetEditing();
          }
        } else if (e.key === 'Escape') {
          // 編集をキャンセル
          e.preventDefault();
          e.stopPropagation();
          contentSpan.textContent = 'Initialize thought sequence...';
          finishNewTweetEditing();
        } else if (e.key === 'Enter' && !e.metaKey && !e.ctrlKey) {
          // 通常のEnterキーは改行として処理
          e.stopPropagation();
        }
      };

      // 新規ツイート入力モード終了時の共通処理
      const finishNewTweetEditing = () => {
        contentSpan.contentEditable = false;
        tweetElement.classList.remove('editing');
        tweetElement.focus();
        document.removeEventListener('keydown', handleEditKeypress);
        contentSpan.removeEventListener('compositionstart', handleCompositionStart);
        contentSpan.removeEventListener('compositionend', handleCompositionEnd);
      };

      // イベントリスナーを追加
      document.addEventListener('keydown', handleEditKeypress);
      contentSpan.addEventListener('compositionstart', handleCompositionStart);
      contentSpan.addEventListener('compositionend', handleCompositionEnd);
    }

    // フォーカス機能の実装
    let focusedTweetIndex = null;

    // マインドフック機能の実装
    let mindHookedTweetIndices = [];
    const MAX_MIND_HOOKS = 3;

    // 既存のフォーカス状態をクリアする関数
    function clearExistingFocusStates() {
      // フォーカスされたツイートからクラスとインジケータを削除
      const focusedElements = document.querySelectorAll('.tweet.focused');
      focusedElements.forEach(tweet => {
        tweet.classList.remove('focused');
        
        const focusIndicator = tweet.querySelector('.focus-indicator');
        if (focusIndicator) {
          focusIndicator.remove();
        }
      });
      
      // LocalStorageからフォーカス状態を削除
      try {
        localStorage.removeItem('focusedTweetIndex');
      } catch (e) {
        console.error('Error removing focus state from localStorage:', e);
      }
    }

    // ツイートにマインドフックを設定する関数
    function toggleMindHookOnTweet() {
      console.log('toggleMindHookOnTweet called');
      
      const focusedTweet = document.activeElement;
      console.log('Active element for mind hook:', focusedTweet);
      
      // 子ツイートも含めて有効なツイートかどうかをチェック
      if (!focusedTweet || (!focusedTweet.classList.contains('tweet') && !focusedTweet.classList.contains('child-tweet'))) {
        console.log('No valid tweet to mind hook');
        return;
      }
      
      // data-actual-index属性から実際のデータ配列内のインデックスを取得
      const actualIndex = parseInt(focusedTweet.getAttribute('data-actual-index'));
      if (isNaN(actualIndex)) {
        console.error('Invalid tweet index');
        return;
      }
      
      console.log('Toggle mind hook on tweet with index:', actualIndex);
      console.log('Current mind hooked tweet indices:', mindHookedTweetIndices);
      
      // 現在のマインドフック状態を確認
      const mindHookIndex = mindHookedTweetIndices.indexOf(actualIndex);
      
      if (mindHookIndex !== -1) {
        // 既にマインドフックされている場合は解除
        console.log('Removing mind hook');
        mindHookedTweetIndices.splice(mindHookIndex, 1);
        
        // ツイートからマインドフッククラスを削除
        focusedTweet.classList.remove('mind-hooked');
        console.log('Removed mind-hooked class from tweet');
        
        const mindHookIndicator = focusedTweet.querySelector('.mind-hook-indicator');
        if (mindHookIndicator) {
          mindHookIndicator.remove();
          console.log('Removed mind hook indicator');
        }
        
        // マトリックスエフェクトを適用
        focusedTweet.classList.add('mind-hook-matrix-effect');
        setTimeout(() => {
          focusedTweet.classList.remove('mind-hook-matrix-effect');
        }, 1000);
      } else {
        // 新しいマインドフックを追加
        console.log('Adding new mind hook');
        
        // 最大数を超える場合は古いものを削除
        if (mindHookedTweetIndices.length >= MAX_MIND_HOOKS) {
          const oldestIndex = mindHookedTweetIndices.shift();
          console.log('Removed oldest mind hook with index:', oldestIndex);
          
          // 古いマインドフックを持つツイートからクラスとインジケータを削除
          const oldestTweet = document.querySelector(`.tweet[data-actual-index="${oldestIndex}"]`);
          if (oldestTweet) {
            oldestTweet.classList.remove('mind-hooked');
            
            const oldIndicator = oldestTweet.querySelector('.mind-hook-indicator');
            if (oldIndicator) {
              oldIndicator.remove();
            }
          }
        }
        
        // 新しいマインドフックを追加
        mindHookedTweetIndices.push(actualIndex);
        
        // マインドフッククラスを追加
        focusedTweet.classList.add('mind-hooked');
        console.log('Added mind-hooked class to tweet');
        
        // マインドフックインジケータを追加
        const contentElement = focusedTweet.querySelector('.content');
        if (contentElement) {
          // 既存のインジケータがあれば削除
          const existingIndicator = contentElement.querySelector('.mind-hook-indicator');
          if (existingIndicator) {
            existingIndicator.remove();
          }
          
          const mindHookIndicator = document.createElement('span');
          mindHookIndicator.className = 'mind-hook-indicator';
          mindHookIndicator.innerHTML = '💭';
          contentElement.insertBefore(mindHookIndicator, contentElement.firstChild);
          console.log('Added mind hook indicator to tweet');
        }
        
        // マトリックスエフェクトを適用
        focusedTweet.classList.add('mind-hook-matrix-effect');
        setTimeout(() => {
          focusedTweet.classList.remove('mind-hook-matrix-effect');
        }, 1000);
      }
      
      // マインドフック状態を保存
      try {
        localStorage.setItem('mindHookedTweetIndices', JSON.stringify(mindHookedTweetIndices));
        console.log('Mind hook state saved:', mindHookedTweetIndices);
      } catch (e) {
        console.error('Error saving mind hook state to localStorage:', e);
      }
      
      // マインドフックカウントを更新
      updateMindHookCount();
    }

    // マインドフックカウントを更新する関数
    function updateMindHookCount() {
      const countElement = document.querySelector('#mindHookBtn .mind-hook-count');
      if (countElement) {
        const count = mindHookedTweetIndices.length;
        countElement.textContent = count.toString();
        countElement.style.display = count > 0 ? 'flex' : 'none';
      }
    }

    // 保存されたマインドフック状態を復元する関数
    function restoreMindHookState() {
      try {
        const savedIndices = localStorage.getItem('mindHookedTweetIndices');
        console.log('Restoring mind hook state, saved indices:', savedIndices);
        
        if (savedIndices) {
          mindHookedTweetIndices = JSON.parse(savedIndices);
          console.log('Parsed mind hook indices:', mindHookedTweetIndices);
          
          // 少し遅延させてDOMが完全に読み込まれた後に実行
          setTimeout(() => {
            // 各マインドフックを適用
            mindHookedTweetIndices.forEach(index => {
              // 親ツイートと子ツイートの両方を検索
              const tweetToHook = document.querySelector(`.tweet[data-actual-index="${index}"], .child-tweet[data-actual-index="${index}"]`);
              console.log('Tweet to mind hook:', tweetToHook);
              
              if (tweetToHook) {
                // マインドフッククラスを追加
                tweetToHook.classList.add('mind-hooked');
                console.log('Added mind-hooked class to tweet');
                
                // マインドフックインジケータを追加
                const contentElement = tweetToHook.querySelector('.content');
                if (contentElement) {
                  // 既存のインジケータがあれば削除
                  const existingIndicator = contentElement.querySelector('.mind-hook-indicator');
                  if (existingIndicator) {
                    existingIndicator.remove();
                  }
                  
                  const mindHookIndicator = document.createElement('span');
                  mindHookIndicator.className = 'mind-hook-indicator';
                  mindHookIndicator.innerHTML = '💭';
                  contentElement.insertBefore(mindHookIndicator, contentElement.firstChild);
                  console.log('Added mind hook indicator to tweet');
                }
              } else {
                console.log('Tweet to mind hook not found for index:', index);
                // 無効なインデックスを配列から削除
                const invalidIndex = mindHookedTweetIndices.indexOf(index);
                if (invalidIndex !== -1) {
                  mindHookedTweetIndices.splice(invalidIndex, 1);
                }
              }
            });
            
            // マインドフックカウントを更新
            updateMindHookCount();
            
            // 無効なインデックスが削除された場合は保存し直す
            localStorage.setItem('mindHookedTweetIndices', JSON.stringify(mindHookedTweetIndices));
          }, 300);
        } else {
          console.log('No mind hooks to restore');
          mindHookedTweetIndices = [];
        }
      } catch (e) {
        console.error('Error restoring mind hook state:', e);
        mindHookedTweetIndices = [];
      }
    }

    // 保存されたフォーカス状態を復元する関数
    function restoreFocusState() {
      // フォーカス機能は無効化するため、何もしない
      console.log('Focus restoration disabled');
      return;
    }

    // イベントリスナーの設定
    document.addEventListener('DOMContentLoaded', () => {
      // ... existing code ...
      
      // フォーカスボタンのイベントリスナー
      document.getElementById('focusBtn').addEventListener('click', () => {
        console.log('Focus button clicked');
        // 現在フォーカスされているツイートがない場合は、最初のツイートにフォーカスを移動
        const currentFocus = document.activeElement;
        if (!currentFocus || !currentFocus.classList.contains('tweet') || currentFocus.classList.contains('child-tweet') || currentFocus.classList.contains('new-tweet')) {
          const firstTweet = document.querySelector('.tweet:not(.child-tweet):not(.new-tweet)');
          if (firstTweet) {
            firstTweet.focus();
          }
        }
        
        // フォーカス機能の代わりにマインドフック機能を実行
        toggleMindHookOnTweet();
      });
      
      // マインドフックボタンのイベントリスナー
      document.getElementById('mindHookBtn').addEventListener('click', () => {
        console.log('Mind Hook button clicked');
        // 現在フォーカスされているツイートがない場合は、最初のツイートにフォーカスを移動
        const currentFocus = document.activeElement;
        if (!currentFocus || !currentFocus.classList.contains('tweet') || currentFocus.classList.contains('child-tweet') || currentFocus.classList.contains('new-tweet')) {
          const firstTweet = document.querySelector('.tweet:not(.child-tweet):not(.new-tweet)');
          if (firstTweet) {
            firstTweet.focus();
          }
        }
        
        // マインドフック機能を実行
        toggleMindHookOnTweet();
      });
      
      // キーボードショートカットの追加
      document.addEventListener('keydown', (e) => {
        // ... existing code ...
        
        // マインドフック機能のショートカット (f)は、メインのイベントリスナーで処理するため、ここでは削除
        // if (e.key === 'f' && !e.ctrlKey && !e.metaKey && !e.altKey && !isEditing()) {
        //   e.preventDefault();
        //   console.log('Mind hook shortcut triggered');
        //   
        //   // 現在フォーカスされているツイートがない場合は、最初のツイートにフォーカスを移動
        //   const currentFocus = document.activeElement;
        //   if (!currentFocus || !currentFocus.classList.contains('tweet') || currentFocus.classList.contains('child-tweet') || currentFocus.classList.contains('new-tweet')) {
        //     const firstTweet = document.querySelector('.tweet:not(.child-tweet):not(.new-tweet)');
        //     if (firstTweet) {
        //       firstTweet.focus();
        //       console.log('Focus moved to first tweet');
        //     }
        //   }
        //   
        //   // マインドフック機能を実行
        //   toggleMindHookOnTweet();
        // }
        
        // マインドフックされたツイートへのスクロール (Alt+↑ と Alt+↓)
        if (e.altKey && !e.ctrlKey && !e.metaKey && !isEditing()) {
          if (e.key === 'ArrowUp') {
            e.preventDefault();
            scrollToMindHookedTweet('prev');
          } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            scrollToMindHookedTweet('next');
          }
        }
      });
      
      // 初期表示時にマインドフック状態のみを復元（フォーカス状態は復元しない）
      // restoreFocusState();
      restoreMindHookState();
    });

    // マインドフックされたツイートへスクロールする関数
    function scrollToMindHookedTweet(direction = 'next') {
      if (mindHookedTweetIndices.length === 0) {
        console.log('No mind hooked tweets to scroll to');
        return;
      }
      
      // 現在アクティブなツイートのインデックスを取得
      const activeElement = document.activeElement;
      let currentIndex = -1;
      
      if (activeElement && (activeElement.classList.contains('tweet') || activeElement.classList.contains('child-tweet'))) {
        const actualIndex = parseInt(activeElement.getAttribute('data-actual-index'));
        if (!isNaN(actualIndex)) {
          currentIndex = mindHookedTweetIndices.indexOf(actualIndex);
        }
      }
      
      // 次または前のマインドフックされたツイートのインデックスを計算
      let targetIndex;
      if (direction === 'next') {
        targetIndex = currentIndex < 0 || currentIndex >= mindHookedTweetIndices.length - 1 ? 0 : currentIndex + 1;
      } else {
        targetIndex = currentIndex <= 0 ? mindHookedTweetIndices.length - 1 : currentIndex - 1;
      }
      
      // 対象のツイートを取得してフォーカス
      const targetTweetIndex = mindHookedTweetIndices[targetIndex];
      const targetTweet = document.querySelector(`.tweet[data-actual-index="${targetTweetIndex}"], .child-tweet[data-actual-index="${targetTweetIndex}"]`);
      
      if (targetTweet) {
        // スムーズにスクロール
        targetTweet.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
        // フォーカスを設定
        setTimeout(() => {
          targetTweet.focus();
          
          // マトリックスエフェクトを適用
          targetTweet.classList.add('mind-hook-matrix-effect');
          setTimeout(() => {
            targetTweet.classList.remove('mind-hook-matrix-effect');
          }, 1000);
        }, 300);
        
        console.log(`Scrolled to mind hooked tweet with index: ${targetTweetIndex}`);
      } else {
        console.log(`Target mind hooked tweet not found for index: ${targetTweetIndex}`);
      }
    }
  </script>
</body>
</html>
